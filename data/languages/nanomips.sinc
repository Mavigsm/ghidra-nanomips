# sleigh include file for Skeleton language instructions

define token instrhi(16)
	hi_pool10_6 = (10, 15)  # MAJOR / P32 / P16
	hi_pool9_1 = (9, 9)
	hi_pool8_1 = (8, 8)
	hi_pool6_1 = (6, 6)
	hi_pool4_1 = (4, 4)
	hi_pool3_2 = (3, 4)
	hi_pool3_1 = (3, 3)
	hi_pool2_3 = (2, 4)
	hi_pool2_2 = (2, 3)
	hi_pool2_1 = (2, 2)
	hi_pool1_1 = (1, 1)
	hi_pool0_5 = (0, 4)  # P48I, P.BR3A
	hi_pool0_4 = (0, 3)  # P16.BR u[4:1]
	hi_pool0_1 = (0, 0)
	
	hint = (5, 9)  # hi_pool5_5
	
	u4_1 = (0, 4)  # u[4:1] - naming convention conflict
	
	rt = (5, 9)
	rs = (0, 4)
	
	rt3 = (7, 9)
	rs3 = (4, 6)
	
	eu_imm7 = (0, 6)
	;
	
define token instrlo(16)
	lo_pool14_2 = (14, 15)
	lo_pool12_4 = (12, 15)
	lo_pool11_4 = (11, 14)
	lo_pool11_1 = (11, 11)
	lo_pool10_3 = (10, 12)
	lo_pool10_1 = (10, 10)
	lo_pool9_7 = (9, 15)
	lo_pool9_5 = (9, 13)
	lo_pool8_3 = (8, 10)
	lo_pool7_4 = (7, 10)
	lo_pool6_4 = (6, 9)
	lo_pool6_3 = (6, 8)
	lo_pool6_1 = (6, 6)
	lo_pool5_4 = (5, 8)
	lo_pool5_1 = (5, 5)
	lo_pool3_7 = (3, 9)
	lo_pool3_3 = (3, 5)
	lo_pool3_2 = (3, 4)
	lo_pool1_1 = (1, 1)
	lo_pool0_3 = (0, 2)
	lo_pool0_2 = (0, 1)
	lo_pool0_1 = (0, 0)
	
	shift = (0, 4)
	
	rd = (11, 15)
	;
	
define token data16(16)
	hi_imm16 = (0, 15) signed
	lo_imm16 = (0, 15)
	uimm16 = (0, 15)
	;

attach variables [ rt rs rd ] [
	zero
	at
	t4 t5
	a0 a1 a2 a3
	a4 a5 a6 a7
	t0 t1 t2 t3
	s0 s1 s2 s3
	s4 s5 s6 s7
	t8 t9
	k0 k1
	gp sp fp ra
];

# gpr3: [16, 17, 18, 19, 4, 5, 6, 7]
attach variables [ rt3 rs3 ] [
	s0 s1 s2 s3
	a0 a1 a2 a3
];

################################################################
# Macros
################################################################

# macro setResultFlags(result) {
# 	$(Z_flag) = (result == 0);
# 	$(S_flag) = (result s< 0);
# }
# 
# macro setAddCarryFlags(op1,op2) {
# 	$(C_flag) = (carry(op1,zext($(C_flag))) || carry(op2,op1 + zext($(C_flag))));
# }
# 
# macro setAddFlags(op1,op2) {
# 	$(C_flag) = carry(op1,op2);
# }
# 
# macro setSubtractCarryFlags(op1,op2) {
# 	notC = ~$(C_flag);
# 	$(C_flag) = ((op1 < sext(notC)) || (op2 < (op1 - sext(notC))));
# }
# 
# macro setSubtractFlags(op1,op2) {
# 	$(C_flag) = (op1 < op2);
# }
# 
# macro push16(val16) {
# 	SP = SP - 2;
# 	*:2 SP = val16; 
# }
# 
# macro pop16(ret16) {
# 	ret16 = *:2 SP;
# 	SP = SP + 2; 
# }
# 
# macro push8(val8) {
# 	SP = SP - 1;
# 	ptr:2 = SP;
# 	*:1 ptr = val8; 
# }
# 
# macro pop8(ret8) {
#     ptr:2 = SP;
# 	ret8 = *:1 ptr;
# 	SP = SP + 1; 
# }
# 
# ################################################################
# ixMem8: (IX+simm8)  is IX & simm8								{ ptr:2 = IX + simm8; export *:1 ptr; }
# ixMem8: (IX-val)    is IX & simm8 & sign8=1	[ val = -simm8; ]	{ ptr:2 = IX + simm8; export *:1 ptr; }
# 
# iyMem8: (IY+simm8)  is IY & simm8								{ ptr:2 = IY + simm8; export *:1 ptr; }
# iyMem8: (IY-val)    is IY & simm8 & sign8=1	[ val = -simm8; ]	{ ptr:2 = IY + simm8; export *:1 ptr; }
# 
# Addr16: imm16		is imm16									{ export *:1 imm16; }
# 
# Mem16: (imm16)		is imm16									{ export *:2 imm16; }
# 
# RelAddr8: loc		is simm8  [ loc = inst_next + simm8; ]		{ export *:1 loc; }
# 
# cc: "NZ"            is bits3_3=0x0                              { c:1 = ($(Z_flag) == 0); export c; }
# cc: "Z"             is bits3_3=0x1                              { c:1 = $(Z_flag); export c; }
# cc: "NC"            is bits3_3=0x2                              { c:1 = ($(C_flag) == 0); export c; }
# cc: "C"             is bits3_3=0x3                              { c:1 = $(C_flag); export c; }
# cc: "PO"            is bits3_3=0x4                              { c:1 = ($(PV_flag) == 0); export c; }
# cc: "PE"            is bits3_3=0x5                              { c:1 = $(PV_flag); export c; }
# cc: "P"             is bits3_3=0x6                              { c:1 = ($(S_flag) == 0); export c; }
# cc: "M"             is bits3_3=0x7                              { c:1 = $(S_flag); export c; }
# 
# cc2: "NZ"            is bits3_3=0x4                              { c:1 = ($(Z_flag) == 0); export c; }
# cc2: "Z"             is bits3_3=0x5                              { c:1 = $(Z_flag); export c; }
# cc2: "NC"            is bits3_3=0x6                              { c:1 = ($(C_flag) == 0); export c; }
# cc2: "C"             is bits3_3=0x7                              { c:1 = $(C_flag); export c; }
# ################################################################

# ADD
## ADD rd, rs, rt
:ADD rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0100010 & lo_pool0_3 = 0b000 {
	rd = rs + rt;
	# TODO: trap on overflow
	# TODO: sign extend?
}

# ADDIU rt, rs, imm

## ADDIU[32]
#:ADDIU rt, rs, uimm16 is hi_pool10_6 = 0b000000 & rt != 0 & rs; uimm16 {
#	rt = rs + uimm16;
#}


# LI
## LI[16]
:LI rt3, s is hi_pool10_6 = 0b110100 & rt3 & eu_imm7 = 127 [s = -1;] {
	rt3 = s;
}

:LI rt3, eu_imm7 is hi_pool10_6 = 0b110100 & rt3 & eu_imm7 {
	rt3 = eu_imm7;
} 

## LI[48]
:LI rt, s32 is hi_pool10_6 = 0b011000 & rt & hi_pool0_5 = 0b00000; lo_imm16; hi_imm16 [s32 = (hi_imm16 << 16) | lo_imm16;] {
	rt = s32;
	# TODO: is signedness maintained correctly?
}


# JRC
:JRC rt is hi_pool10_6 = 0b110110 & rt & hi_pool4_1 = 0 & hi_pool0_4 = 0b0000 {
	pc = rt;
}


