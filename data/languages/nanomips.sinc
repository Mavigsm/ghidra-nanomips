# sleigh include file for Skeleton language instructions

define token instrhi(16)
	# opcode bits
	hi_pool10_6 = (10, 15)  # MAJOR / P32 / P16
	hi_pool9_1 = (9, 9)
	hi_pool8_1 = (8, 8)
	hi_pool6_1 = (6, 6)
	hi_pool5_5 = (5, 9)
	hi_pool4_1 = (4, 4)
	hi_pool3_2 = (3, 4)
	hi_pool3_1 = (3, 3)
	hi_pool2_3 = (2, 4)
	hi_pool2_2 = (2, 3)
	hi_pool2_1 = (2, 2)
	hi_pool1_2 = (1, 2)
	hi_pool1_1 = (1, 1)
	hi_pool0_5 = (0, 4)  # P48I, P.BR3A
	hi_pool0_4 = (0, 3)  # P16.BR u[4:1]
	hi_pool0_3 = (0, 2)
	hi_pool0_2 = (0, 1)
	hi_pool0_1 = (0, 0)
	
	hint = (5, 9)  # hi_pool5_5
	count = (0, 3)
	
	u4_1 = (0, 4)  # u[4:1] - naming convention conflict
	
	# normal register encodings
	rt = (5, 9)
	rt_raw = (5, 9)  # :'(
	rs_from_rt = (5, 9)  # :'(
	rs = (0, 4)
	
	c0s = (0, 4) # for MFC0

	# 1 bit register encodings
	rt1_raw = (9, 9)

	rd1 = (8, 8)

	# 2 bit register encodings
	# disjointed msb requires group per possible bit value (see issue #4140)
	rd2_msb0 = (8, 8)
	rd2_msb1 = (8, 8)
	rd2_msb0_reg2 = (8, 8)
	rd2_msb1_reg2 = (8, 8)
	rd2_msb = (3, 3)

	# 3 bit register encodings
	rt3 = (7, 9)
	rt3_raw = (7, 9)
	rd3_from_rt3 = (7, 9)
	rtz3 = (7, 9)

	rs3 = (4, 6)
	rs3_raw = (4, 6)

	rd3 = (1, 3)

	# 4 bit register encodings
	# disjointed msb requires group per possible bit value (see issue #4140)
	rt4_msb0 = (5, 7)
	rt4_msb1 = (5, 7)
	rtz4_msb0 = (5, 7)
	rtz4_msb1 = (5, 7)
	rd4_from_rt4_msb0 = (5, 7)
	rd4_from_rt4_msb1 = (5, 7)
	rt4_msb = (9, 9)
	rtz4_msb = (9, 9)

	rs4_msb0 = (0, 2)
	rs4_msb1 = (0, 2)
	rsz4_msb0 = (0, 2)
	rsz4_msb1 = (0, 2)
	rs4_msb = (4, 4)
	rsz4_msb = (4, 4)

	# data in same token as opcode bits
	eu_imm7 = (0, 6)
	hi_uimm8_1 = (8, 8)
	hi_uimm4_4 = (4, 7)
	hi_uimm3_1 = (3, 3)
	hi_uimm1_2 = (1, 2)
	hi_uimm0_10 = (0, 9)
	hi_uimm0_7 = (0, 6)
	hi_uimm0_2 = (0, 1)
	hi_uimm0_5 = (0, 4)
	hi_uimm0_6 = (0, 5)
	hi_uimm0_4 = (0, 3)
	hi_uimm0_3 = (0, 2)
	hi_uimm0_1 = (0, 0)

	hi_simm4_1 = (4, 4)
	hi_simm1_6 = (1, 6)
	hi_simm1_9 = (1, 9)
	hi_simm0_9 = (0, 8)
	hi_simm0_5 = (0, 4)
	hi_simm0_3 = (0, 2)
	hi_simm0_1 = (0, 0)
	hi_signbit0_1 = (0, 0) signed

	u_imm5 = (0, 4)
	eu_imm4 = (0, 3)
	u_imm4_4 = (4, 7)
	u_imm4 = (0, 3)
	;
	
define token instrlo(16)
	# opcode bits
	lo_pool15_1 = (15, 15)
	lo_pool14_2 = (14, 15)
	lo_pool12_4 = (12, 15)
	lo_pool12_3 = (12, 14)
	lo_pool11_5 = (11, 15)
	lo_pool11_4 = (11, 14)
	lo_pool11_1 = (11, 11)
	lo_pool10_3 = (10, 12)
	lo_pool10_1 = (10, 10)
	lo_pool9_7 = (9, 15)
	lo_pool9_5 = (9, 13)
	lo_pool9_2 = (9, 10)
	lo_pool8_3 = (8, 10)
	lo_pool8_2 = (8, 9)
	lo_pool7_4 = (7, 10)
	lo_pool6_4 = (6, 9)
	lo_pool6_3 = (6, 8)
	lo_pool6_1 = (6, 6)
	lo_pool5_4 = (5, 8)
	lo_pool5_1 = (5, 5)
	lo_pool3_9 = (3, 11)
	lo_pool3_7 = (3, 9)
	lo_pool3_5 = (3, 7)
	lo_pool3_3 = (3, 5)
	lo_pool3_2 = (3, 4)
	lo_pool2_14 = (2, 15)
	lo_pool2_10 = (2, 11)
	lo_pool2_6 = (2, 7)
	lo_pool2_2 = (2, 3)
	lo_pool2_1 = (2, 2)
	lo_pool1_15 = (1, 15)
	lo_pool1_1 = (1, 1)
	lo_pool0_16 = (0, 15)
	lo_pool0_12 = (0, 11)
	lo_pool0_8 = (0, 7)
	lo_pool0_5 = (0, 4)
	lo_pool0_3 = (0, 2)
	lo_pool0_2 = (0, 1)
	lo_pool0_1 = (0, 0)

	gp_end = (2, 2)
	shift = (0, 4)
	
	rd = (11, 15)
	
	sel = (11, 15) # for MFC0

	count3 = (12, 14)

	# data in same token as opcode bits
	lo_uimm11_5 = (11, 15)
	lo_uimm6_5 = (6, 10)
	lo_uimm3_9 = (3, 11)
	lo_uimm2_14 = (2, 15)
	lo_uimm1_15 = (1, 15)
	lo_uimm0_12 = (0, 11)
	lo_uimm0_5 = (0, 4)

	lo_simm12_4 = (12, 15)
	lo_simm2_10 = (2, 11)
	lo_simm1_15 = (1, 15)
	lo_simm1_13 = (1, 13)
	lo_simm1_10 = (1, 10)
	lo_simm1_1 = (1, 1)
	lo_simm0_8 = (0, 7)

	lo_signbit15_1 = (15, 15) signed
	lo_signbit0_1 = (0, 0) signed
	;
	
define token data16(16)
	hi_imm16 = (0, 15) signed
	lo_imm16 = (0, 15)
	
	# TODO move/rename any immediate fields that can be mixed with opcode bits
	uimm16 = (0, 15)
	uimm2_14 = (2, 15)
	uimm0_2 = (0, 1)
	;

attach variables [ rt rs rs_from_rt rd ] [
	zero
	at
	t4 t5
	a0 a1 a2 a3
	a4 a5 a6 a7
	t0 t1 t2 t3
	s0 s1 s2 s3
	s4 s5 s6 s7
	t8 t9
	k0 k1
	gp sp fp ra
];

# SAVE rt1
#attach variables [ rt1 ] [
#	fp ra
#];

# gpr1: [4, 5]
attach variables [ rd1 ] [
	a0 a1
];

# gpr2.reg1: [4, 5, 6, 7]
attach variables [ rd2_msb0 ] [
	a0 a1
];

attach variables [ rd2_msb1 ] [
	a2 a3
];

# gpr2.reg2: [5, 6, 7, 8]
attach variables [ rd2_msb0_reg2 ] [
	a1 a2
];

attach variables [ rd2_msb1_reg2 ] [
	a3 a4
];

# gpr3: [16, 17, 18, 19, 4, 5, 6, 7]
attach variables [ rt3 rs3 rd3 rd3_from_rt3 ] [
	s0 s1 s2 s3
	a0 a1 a2 a3
];

# gpr3.src.store: [0, 17, 18, 19, 4, 5, 6, 7]
attach variables [ rtz3 ] [
	zero s1 s2 s3
	a0 a1 a2 a3
];

# gpr4: Standard list of 16 GPRs used by 16 bit instructions not in MMS.
# gpr_list = [8, 9, 10, 11, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 23]

# encoding sadness edition :'(
attach variables [ rt4_msb0 rs4_msb0 rd4_from_rt4_msb0 ] [
	a4 a5 a6 a7
	a0 a1 a2 a3
];

attach variables [ rt4_msb1 rs4_msb1 rd4_from_rt4_msb1 ] [
	s0 s1 s2 s3
	s4 s5 s6 s7
];

# gpr4.zero: Source GPR used by store and movep instructions. Use $0 instead of a7
# gpr_list = [8, 9, 10, 0, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 23]
attach variables [ rtz4_msb0 rsz4_msb0 ] [
	a4 a5 a6 zero
	a0 a1 a2 a3
];

attach variables [ rtz4_msb1 rsz4_msb1 ] [
	s0 s1 s2 s3
	s4 s5 s6 s7
];


attach values [count3] [8 1 2 3 4 5 6 7];

################################################################
# Macros
################################################################

# macro setResultFlags(result) {
# 	$(Z_flag) = (result == 0);
# 	$(S_flag) = (result s< 0);
# }
# 
# macro setAddCarryFlags(op1,op2) {
# 	$(C_flag) = (carry(op1,zext($(C_flag))) || carry(op2,op1 + zext($(C_flag))));
# }
# 
# macro setAddFlags(op1,op2) {
# 	$(C_flag) = carry(op1,op2);
# }
# 
# macro setSubtractCarryFlags(op1,op2) {
# 	notC = ~$(C_flag);
# 	$(C_flag) = ((op1 < sext(notC)) || (op2 < (op1 - sext(notC))));
# }
# 
# macro setSubtractFlags(op1,op2) {
# 	$(C_flag) = (op1 < op2);
# }
# 
# macro push16(val16) {
# 	SP = SP - 2;
# 	*:2 SP = val16; 
# }
# 
# macro pop16(ret16) {
# 	ret16 = *:2 SP;
# 	SP = SP + 2; 
# }
# 
# macro push8(val8) {
# 	SP = SP - 1;
# 	ptr:2 = SP;
# 	*:1 ptr = val8; 
# }
# 
# macro pop8(ret8) {
#     ptr:2 = SP;
# 	ret8 = *:1 ptr;
# 	SP = SP + 1; 
# }
# 
# ################################################################
# ixMem8: (IX+simm8)  is IX & simm8								{ ptr:2 = IX + simm8; export *:1 ptr; }
# ixMem8: (IX-val)    is IX & simm8 & sign8=1	[ val = -simm8; ]	{ ptr:2 = IX + simm8; export *:1 ptr; }
# 
# iyMem8: (IY+simm8)  is IY & simm8								{ ptr:2 = IY + simm8; export *:1 ptr; }
# iyMem8: (IY-val)    is IY & simm8 & sign8=1	[ val = -simm8; ]	{ ptr:2 = IY + simm8; export *:1 ptr; }
# 
# Addr16: imm16		is imm16									{ export *:1 imm16; }
# 
# Mem16: (imm16)		is imm16									{ export *:2 imm16; }
# 
# RelAddr8: loc		is simm8  [ loc = inst_next + simm8; ]		{ export *:1 loc; }
# 
# cc: "NZ"            is bits3_3=0x0                              { c:1 = ($(Z_flag) == 0); export c; }
# cc: "Z"             is bits3_3=0x1                              { c:1 = $(Z_flag); export c; }
# cc: "NC"            is bits3_3=0x2                              { c:1 = ($(C_flag) == 0); export c; }
# cc: "C"             is bits3_3=0x3                              { c:1 = $(C_flag); export c; }
# cc: "PO"            is bits3_3=0x4                              { c:1 = ($(PV_flag) == 0); export c; }
# cc: "PE"            is bits3_3=0x5                              { c:1 = $(PV_flag); export c; }
# cc: "P"             is bits3_3=0x6                              { c:1 = ($(S_flag) == 0); export c; }
# cc: "M"             is bits3_3=0x7                              { c:1 = $(S_flag); export c; }
# 
# cc2: "NZ"            is bits3_3=0x4                              { c:1 = ($(Z_flag) == 0); export c; }
# cc2: "Z"             is bits3_3=0x5                              { c:1 = $(Z_flag); export c; }
# cc2: "NC"            is bits3_3=0x6                              { c:1 = ($(C_flag) == 0); export c; }
# cc2: "C"             is bits3_3=0x7                              { c:1 = $(C_flag); export c; }
# ################################################################

# disjointed register encodings
rd2_reg1: rd2_msb0 is rd2_msb = 0b0 & rd2_msb0 {export rd2_msb0;}
rd2_reg1: rd2_msb1 is rd2_msb = 0b1 & rd2_msb1 {export rd2_msb1;}

rd2_reg2: rd2_msb0_reg2 is rd2_msb = 0b0 & rd2_msb0_reg2 {export rd2_msb0_reg2;}
rd2_reg2: rd2_msb1_reg2 is rd2_msb = 0b1 & rd2_msb1_reg2 {export rd2_msb1_reg2;}

rt4: rt4_msb0 is rt4_msb = 0b0 & rt4_msb0 {export rt4_msb0;}
rt4: rt4_msb1 is rt4_msb = 0b1 & rt4_msb1 {export rt4_msb1;}

rd4_from_rt4: rd4_from_rt4_msb0 is rt4_msb = 0b0 & rd4_from_rt4_msb0 {export rd4_from_rt4_msb0;}
rd4_from_rt4: rd4_from_rt4_msb1 is rt4_msb = 0b1 & rd4_from_rt4_msb1 {export rd4_from_rt4_msb1;}

rs4: rs4_msb0 is rs4_msb = 0b0 & rs4_msb0 {export rs4_msb0;}
rs4: rs4_msb1 is rs4_msb = 0b1 & rs4_msb1 {export rs4_msb1;}

rtz4: rtz4_msb0 is rtz4_msb = 0b0 & rtz4_msb0 {export rtz4_msb0;}
rtz4: rtz4_msb1 is rtz4_msb = 0b1 & rtz4_msb1 {export rtz4_msb1;}

rsz4: rsz4_msb0 is rsz4_msb = 0b0 & rsz4_msb0 {export rsz4_msb0;}
rsz4: rsz4_msb1 is rsz4_msb = 0b1 & rsz4_msb1 {export rsz4_msb1;}

rs_scale2: rs is rs
	{
		# TODO effective_address
		local addr:4 = rs * 2 + inst_next;
		export *[ram]:4 addr;
	}

buimm7: uimm7 is
	hi_uimm0_2; lo_uimm11_5
	[
		uimm7 = (hi_uimm0_2 << 5) | lo_uimm11_5;
	]
	{
		local tmp:4 = uimm7;
		export tmp;
	}

pc_rel_saddr32: addr is
	lo_imm16; hi_imm16
	[
		addr = inst_next + ((hi_imm16 << 16) | lo_imm16);
	]
	{
		# TODO effective_address
		export *[ram]:4 addr;
	}

hilo_saddr26: addr is
	 hi_simm0_9; lo_simm1_15 & lo_signbit0_1
	[
		addr = inst_next + ((lo_signbit0_1 << 25) | (hi_simm0_9 << 16) | (lo_simm1_15 << 1));
	]
	{
		# TODO should be effective_address(addr)
		export *[ram]:4 addr;
	}

hilo_saddr22: addr is
	 hi_simm0_5; lo_simm1_15 & lo_signbit0_1
	[
		addr = inst_next + ((lo_signbit0_1 << 21) | (hi_simm0_5 << 16) | (lo_simm1_15 << 1));
	]
	{
		# TODO should be effective_address(addr)
		export *[ram]:4 addr;
	}

hi_uaddr5: addr is hi_uimm0_4
	[
		addr = inst_next + (hi_uimm0_4 << 1);
	]
	{
		# TODO effective_address
		export *[ram]:4 addr;
	}

hi_saddr8: addr is
	hi_simm1_6 & hi_signbit0_1
	[
		addr = inst_next + ((hi_signbit0_1 << 7) | (hi_simm1_6 << 1));
	]
	{
		# TODO effective_address
		export *[ram]:4 addr;
	}

hi_saddr11: addr is hi_simm1_9 & hi_signbit0_1
	[
		addr = inst_next + ((hi_signbit0_1 << 10) | (hi_simm1_9 << 1));
	]
	{
		# TODO effective_address
		export *[ram]:4 addr;
	}

lo_saddr12: addr is lo_simm1_10 & lo_signbit0_1
	[
		addr = inst_next + ((lo_signbit0_1 << 11) | (lo_simm1_10 << 1));
	]
	{
		# TODO effective_address
		export *[ram]:4 addr;
	}

lo_saddr15: addr is lo_simm1_13 & lo_signbit0_1
	[
		addr = inst_next + ((lo_signbit0_1 << 14) | (lo_simm1_13 << 1));
	]
	{
		# TODO effective_address
		export *[ram]:4 addr;
	}

hi_uoffset8_sl4: offs is
	hi_uimm4_4
	[
		offs = hi_uimm4_4 << 4;
	]
	{
		local tmp:4 = offs;
		export tmp;
	}

lo_soffset9: offs is lo_signbit15_1 & lo_simm0_8
	[
		offs = (lo_signbit15_1 << 8) | lo_simm0_8;
	]
	{
		local tmp:4 = offs;
		export tmp;
	}

hilo_gp_uoffset18_sl1: offs(gp) is
	gp & hi_uimm0_2; lo_uimm1_15
	[
		offs = (hi_uimm0_2 << 16) | (lo_uimm1_15 << 1);
	]
	{
		local addr = gp + offs;
		export *[ram]:4 addr;
	}

hilo_gp_uoffset18: offs(gp) is
	gp & hi_uimm0_2; uimm16
	[
		offs = (hi_uimm0_2 << 16) | uimm16;
	]
	{
		local addr = gp + offs;
		export *[ram]:4 addr;
	}

hilo_gp_uoffset21: offs(gp) is
	gp & hi_uimm0_5; lo_uimm2_14
	[
		offs = (hi_uimm0_5 << 16) | (lo_uimm2_14 << 2);
	]
	{
		local addr = gp + offs;
		export *[ram]:4 addr;
	}

hi_gp_uoffset9: offs(gp) is
	gp & hi_uimm0_7
	[
		offs = hi_uimm0_7 << 2;
	]
	{
		local addr = gp + offs;
		export *[ram]:4 addr;
	}

hi_sp_uoffset7: offs(sp) is
	sp & hi_uimm0_5
	[
		offs = hi_uimm0_5 << 2;
	]
	{
		local addr = sp + offs;
		export *[ram]:4 addr;
	}

hi_rs3_uoffset6: offs(rs3) is
	rs3 & hi_uimm0_4
	[
		offs = hi_uimm0_4 << 2;
	]
	{
		local addr = rs3 + offs;
		export *[ram]:4 addr;
	}

hi_rs3_uoffset3: offs(rs3) is
	rs3 & hi_uimm1_2
	[
		offs = hi_uimm1_2 << 1;
	]
	{
		local addr = rs3 + offs;
		export *[ram]:4 addr;
	}

hi_rs3_uoffset2: hi_uimm0_2(rs3) is
	rs3 & hi_uimm0_2
	{
		local addr = rs3 + hi_uimm0_2;
		export *[ram]:4 addr;
	}

hi_rs4_uoffset4: offs(rs4) is
	rs4 & hi_uimm8_1 & hi_uimm3_1
	[
		offs = (hi_uimm3_1 << 3) | (hi_uimm8_1 << 2);
	]
	{
		local addr = rs4 + offs;
		export *[ram]:4 addr;
	}

lo_rs_uoffset12: lo_uimm0_12(rs) is
	rs; lo_uimm0_12
	{
		local addr = rs + lo_uimm0_12;
		export *[ram]:4 addr;
	}

lo_rs_soffset9: lo_soffset9(rs) is
	rs; lo_soffset9
	{
		local addr = rs + lo_soffset9;
		export *[ram]:4 addr;
	}

rt_offset_rs: rs(rt) is
	rt & rs
	{
		# TODO effective_address
		local addr = rt + rs;
		export *[ram]:4 addr;
	}

rt_offset_4rs: rs(rt) is
	rt & rs
	{
		# TODO effective_address
		local addr = rt + 4 * rs;
		export *[ram]:4 addr;
	}

rt3_offset_4rs3: rs3(rt3) is
	rt3 & rs3
	{
		# TODO effective_address
		local addr = rt3 + 4 * rs3;
		export *[ram]:4 addr;
	}

hilo_simm32: simm32 is
	hi_simm0_5;
	lo_simm12_4 & lo_simm2_10 & lo_signbit0_1
	[
		simm32 = (lo_signbit0_1 << 31) | (lo_simm2_10 << 21) | (hi_simm0_5 << 16) | (lo_simm12_4 << 12);
	]
	{
		local tmp:4 = simm32;
		export tmp;
	}

lo_uimm12_sl3: uimm12 is
	lo_uimm3_9
	[
		uimm12 = lo_uimm3_9 << 3;
	]
	{
		local tmp:4 = uimm12;
		export tmp;
	}


# ADD rd, rs, rt
:ADD rd, rs, rt is
	hi_pool10_6 = 0b001000 & rt & rs;
	rd & lo_pool3_7 = 0b0100010 & lo_pool0_3 = 0b000
	{
		rd = rs + rt;
		# TODO: trap on overflow
		# TODO: sign extend?
	}


# ADDIU rt, rs, imm
## ADDIU[32]
:ADDIU rt, rs, uimm16 is
	hi_pool10_6 = 0b000000 & rt & rt_raw != 0 & rs;
	uimm16
	{
		rt = rs + uimm16;
	}

## ADDIU[48]
:ADDIU rt, rs_from_rt, s32 is
	hi_pool10_6 = 0b011000 & rt & rs_from_rt & hi_pool0_5 = 0b00001;
	lo_imm16; hi_imm16
	[
		s32 = (hi_imm16 << 16) | lo_imm16;
	] {
		# TODO signedness
		rt = rs_from_rt + s32;
	}

## ADDIU[GP48]
# TODO: not available in P64 mode
:ADDIU rt, gp, s32 is
	gp & hi_pool10_6 = 0b011000 & rt & hi_pool0_5 = 0b00010;
	lo_imm16; hi_imm16
	[
		s32 = (hi_imm16 << 16) | lo_imm16;
	]
	{
		# TODO signedness
		# rs = $r28 = gp
		rt = gp + s32;
	}

## ADDIU[GP.B]
# TODO: not available in P64 mode
:ADDIU rt, gp, u18 is
	gp & hi_pool10_6 = 0b010001 & rt & hi_pool2_3 = 0b011 & hi_uimm0_2;
	uimm16
	[
		u18 = (hi_uimm0_2 << 16) | uimm16;
	]
	{
		rt = gp + u18;
	}

## ADDIU[GP.W]
# TODO: not available in P64 mode
:ADDIU rt, gp, u21 is
	gp & hi_pool10_6 = 0b010000 & rt & hi_uimm0_5;
	uimm2_14 & uimm0_2 = 0b00
	[
		u21 = (hi_uimm0_5 << 18) | (uimm2_14 << 2);
	]
	{
		rt = gp + u21;
	}

## ADDIU[R1.SP]
# TODO: not available in P64 mode
:ADDIU rt3, sp, u8 is
	sp & hi_pool10_6 = 0b011100 & rt3 & hi_pool6_1 = 0b1 & hi_uimm0_6
	[
		u8 = hi_uimm0_6 << 2;
	]
	{
		rt3 = sp + u8;
	}

## ADDIU[R2]
:ADDIU rt3, rs3, u5 is
	hi_pool10_6 = 0b100100 & rt3 & rs3 & hi_pool3_1 = 0b0 & hi_uimm0_3
	[
		u5 = hi_uimm0_3 << 2;
	]
	{
		rt3 = rs3 + u5;
	}

## ADDIU[RS5]
### ADDIU[RS5] with rt=0 is used to provide a 16 bit NOP instruction.
:NOP is
	hi_pool10_6 = 0b100100 & rt = 0 & hi_pool3_1 = 0b1
	{}

:ADDIU rt, rs_from_rt, s4 is
	hi_pool10_6 = 0b100100 & rt & rs_from_rt & hi_simm4_1 & hi_pool3_1 = 0b1 & hi_simm0_3
	[
		s4 = (hi_simm4_1 << 3) | hi_simm0_3;
	]
	{
		rt = rs_from_rt + s4;
		# TODO s4 is signed
	}

## ADDIU[NEG]
:ADDIU rt, rs, lo_uimm0_12 is
	hi_pool10_6 = 0b100000 & rt & rs;
	lo_pool12_4 = 0b1000 & lo_uimm0_12
	{
		rt = rs - lo_uimm0_12;
	}


# ADDIUPC rt, imm
## ADDIUPC[32], TODO not available in P64 mode
:ADDIUPC rt, simm22 is
	hi_pool10_6 = 0b000001 & rt & hi_simm0_5;
	lo_simm1_15 & lo_signbit0_1
	[
		simm22 = ((lo_signbit0_1 << 21) | (lo_simm1_15 << 1)) + 4;
	]
	{
		# TODO effective_address() - exception on overflowing 32 bits
		rt = inst_next + simm22;
	}

## ADDIUPC[48], not available in NMS, TODO not available in P64 mode
:ADDIUPC rt, simm32 is
	hi_pool10_6 = 0b011000 & rt & hi_pool0_5 = 0b00011;
	lo_imm16; hi_imm16
	[
		simm32 = ((hi_imm16 << 16) | lo_imm16) + 6;
	]
	{
		# TODO effective_address()
		rt = inst_next + simm32;
	}


# ADDU dst, src1, src2
## ADDU[32]
:ADDU rd, rs, rt is
	hi_pool10_6 = 0b001000 & rt & rs;
	rd & lo_pool3_7 = 0b0101010 & lo_pool0_3 = 0b000
	{
		# TODO sign extend sum?
		rd = rs + rt;
	}

## ADDU[16]
:ADDU rd3, rs3, rt3 is
	hi_pool10_6 = 0b101100 & rt3 & rs3 & rd3 & hi_pool0_1 = 0b0
	{
		# TODO sign extend sum?
		rd3 = rs3 + rt3;
	}

## ADDU[4X4], not available in NMS
:ADDU rd4_from_rt4, rt4, rs4 is
	hi_pool10_6 = 0b001111 & hi_pool8_1 = 0b0 & rt4 & rd4_from_rt4 & hi_pool3_1 = 0b0 & rs4
	{
		# TODO sign extend sum?
		rd4_from_rt4 = rt4 + rs4;
	}


# AND
## AND rd, rs, rt
:AND rd, rs, rt is
	hi_pool10_6 = 0b001000 & rt & rs;
	rd & lo_pool3_7 = 0b1001010 & lo_pool0_3 = 0b000
	{
		rd = rs & rt;
	}

## AND[16]
:AND rt3, rs3 is
	hi_pool10_6 = 0b010100 & rt3 & rs3 & hi_pool2_2 = 0b10 & hi_pool1_1 = 0 & hi_pool0_1 = 0
	{
		rt3 = rs3 & rt3;
	}


# ANDI rt, rs, u
## ANDI[32]
:ANDI rt, rs, lo_uimm0_12 is
	hi_pool10_6 = 0b100000 & rt & rs;
	lo_pool12_4 = 0b0010 & lo_uimm0_12
	{
		rt = rs & lo_uimm0_12;
	}

## ANDI[16]
:ANDI rt3, rs3, eu_imm4 is
	hi_pool10_6 = 0b111100 & rt3 & rs3 & eu_imm4
	{
		rt3 = rs3 & eu_imm4;
	}


# ALUIPC rt, %pcrel_hi(address)
:ALUIPC rt, "%pcrel_hi"(addr) is
	hi_pool10_6 = 0b111000 & rt & hi_simm0_5;
	lo_simm12_4 & lo_simm2_10 & lo_simm1_1 = 0b1 & lo_signbit0_1
	[
		addr = (((lo_signbit0_1 << 31) | (lo_simm2_10 << 21) | (hi_simm0_5 << 16) | (lo_simm12_4 << 12)) + inst_next) & ~0xfff;
	]
	{
		rt = addr;
	}


# BALC address
## BALC[32]
:BALC hilo_saddr26 is
	(hi_pool10_6 = 0b001010 & hi_pool9_1 = 0b1) ... & hilo_saddr26
	{
		ra = inst_next;
		call hilo_saddr26;
	}

## BALC[16]
:BALC hi_saddr11 is
	hi_pool10_6 = 0b001110 & hi_saddr11
	{
		ra = inst_next;
		call hi_saddr11;
	}


# BALRSC rt, rs
:BALRSC rt, rs_scale2 is
	hi_pool10_6 = 0b010010 & rt & rt_raw != 0 & rs_scale2;
	lo_pool12_4 = 0b1000
	{
		rt = inst_next;
		call rs_scale2;
	}


# BBEQZC rt, bit, address
:BBEQZC rt, bitpos, lo_saddr12 is
	hi_pool10_6 = 0b110010 & rt & hi_pool2_3 = 0b001 & hi_uimm0_1;
	lo_uimm11_5 & lo_saddr12
	[
		bitpos = (hi_uimm0_1 << 5) | lo_uimm11_5;
	]
	{
		local testbit:4 = (rt >> bitpos) & 1;
		if (testbit == 0) goto lo_saddr12;
	}


# BBNEZC rt, bit, address
:BBNEZC rt, bitpos, lo_saddr12 is
	hi_pool10_6 = 0b110010 & rt & hi_pool2_3 = 0b101 & hi_uimm0_1;
	lo_uimm11_5 & lo_saddr12
	[
		bitpos = (hi_uimm0_1 << 5) | lo_uimm11_5;
	]
	{
		local testbit:4 = (rt >> bitpos) & 1;
		if (testbit == 1) goto lo_saddr12;
	}


# BC address
## BC[32]
:BC hilo_saddr26 is
	(hi_pool10_6 = 0b001010 & hi_pool9_1 = 0b0) ... & hilo_saddr26
	{
		# TODO should be effective_address(addr)
		ra = inst_next;
		call hilo_saddr26;
	}

## BC[16]
:BC hi_saddr11 is
	hi_pool10_6 = 0b000110 & hi_saddr11
	{
		# TODO should be effective_address(addr)
		ra = inst_next;
		call hi_saddr11;
	}


# BEQC rs, rt, address
## BEQC[32]
:BEQC rs, rt, lo_saddr15 is
	hi_pool10_6 = 0b100010 & rt & rs;
	lo_pool14_2 = 0b00 & lo_saddr15
	{
		# TODO "not_in_mms = False" ?
		if (rs == rt) goto lo_saddr15;
	}

## BEQC[16], not available in NMS (with rs3<rt3 && u!=0)
:BEQC rs3, rt3, hi_uaddr5 is
	hi_pool10_6 = 0b110110 & rt3 & rs3 & rs3_raw < rt3_raw & hi_uimm0_4 != 0 & hi_uaddr5
	{
		if (rs3 == rt3) goto hi_uaddr5;
	}


# BEQIC rt, u, address
:BEQIC rt, buimm7, lo_saddr12 is
	(hi_pool10_6 = 0b110010 & rt & hi_pool2_3 = 0b000; lo_saddr12)
	& buimm7
	{
		if (rt == buimm7) goto lo_saddr12;
	}


# BEQZC rt, address
## BEQZC[16]
:BEQZC rt3, hi_saddr8 is
	hi_pool10_6 = 0b100110 & rt3 & hi_saddr8
	{
		if (rt3 == 0) goto hi_saddr8;
	}


# BGEC rs, rt, address
:BGEC rs, rt, lo_saddr15 is
	hi_pool10_6 = 0b100010 & rt & rs;
	lo_pool14_2 = 0b10 & lo_saddr15
	{
		if (rs s>= rt) goto lo_saddr15;
	}


# BGEIC rt, u, address
:BGEIC rt, buimm7, lo_saddr12 is
	(hi_pool10_6 = 0b110010 & rt & hi_pool2_3 = 0b010; lo_saddr12)
	& buimm7
	{
		if (rt s>= buimm7) goto lo_saddr12;
	}


# BGEIUC rt, u, address
:BGEIUC rt, buimm7, lo_saddr12 is
	(hi_pool10_6 = 0b110010 & rt & hi_pool2_3 = 0b011; lo_saddr12)
	& buimm7
	{
		# rt explicitly treated as unsigned
		if (rt >= buimm7) goto lo_saddr12;
	}


# BGEUC rs, rt, address
:BGEUC rs, rt, lo_saddr15 is
	hi_pool10_6 = 0b100010 & rt & rs;
	lo_pool14_2 = 0b11 & lo_saddr15
	{
		# rs & rt explicitly treated as unsigned
		if (rs >= rt) goto lo_saddr15;
	}


# BLTC rs, rt, address
:BLTC rs, rt, lo_saddr15 is
	hi_pool10_6 = 0b101010 & rt & rs;
	lo_pool14_2 = 0b10 & lo_saddr15
	{
		if (rs s< rt) goto lo_saddr15;
	}


# BLTIC rt, u, address
:BLTIC rt, buimm7, lo_saddr12 is
	(hi_pool10_6 = 0b110010 & rt & hi_pool2_3 = 0b110; lo_saddr12)
	& buimm7
	{
		if (rt s< buimm7) goto lo_saddr12;
	}


# BLTIUC rt, u, address
:BLTIUC rt, buimm7, lo_saddr12 is
	(hi_pool10_6 = 0b110010 & rt & hi_pool2_3 = 0b111; lo_saddr12)
	& buimm7
	{
		# rt explicitly treated as unsigned
		if (rt < buimm7) goto lo_saddr12;
	}


# BLTUC rs, rt, address
:BLTUC rs, rt, lo_saddr15 is
	hi_pool10_6 = 0b101010 & rt & rs;
	lo_pool14_2 = 0b11 & lo_saddr15
	{
		# rs/rt explicitly unsigned
		if (rs < rt) goto lo_saddr15;
	}


# BNEC rs, rt, address
## BNEC[32]
:BNEC rs, rt, lo_saddr15 is
	hi_pool10_6 = 0b101010 & rt & rs;
	lo_pool14_2 = 0b00 & lo_saddr15
	{
		if (rs != rt) goto lo_saddr15;
	}

## BNEC[16], not available in NMS
:BNEC rs3, rt3, hi_uaddr5 is
	hi_pool10_6 = 0b110110 & rt3 & rs3 & rs3_raw >= rt3_raw & hi_uimm0_4 != 0 & hi_uaddr5
	{
		if (rs3 != rt3) goto hi_uaddr5;
	}


# BNEIC rt, u, address
:BNEIC rt, buimm7, lo_saddr12 is
	(hi_pool10_6 = 0b110010 & rt & hi_pool2_3 = 0b100; lo_saddr12)
	& buimm7
	{
		if (rt != buimm7) goto lo_saddr12;
	}


# BNEZC rt, address
## BNEZC[16]
:BNEZC rt3, hi_saddr8 is
	hi_pool10_6 = 0b101110 & rt3 & hi_saddr8
	{
		if (rt3 != 0) goto hi_saddr8;
	}


# BREAK code
## BREAK[32]
:BREAK code is
	hi_pool10_6 = 0b000000 & rt = 0 & hi_pool3_2 = 0b10 & hi_uimm0_3;
	uimm16
	[
		code = (hi_uimm0_3 << 16) | uimm16;
	]
	unimpl # TODO raise breakpoint exception ("BP")

## BREAK[16]
:BREAK hi_uimm0_3 is
	hi_pool10_6 = 0b000100 & rt = 0 & hi_pool3_2 = 0b10 & hi_uimm0_3
	unimpl # TODO raise breakpoint exception ("BP")


# BRSC rs
:BRSC rs_scale2 is
	hi_pool10_6 = 0b010010 & rt = 0 & rs_scale2;
	lo_pool12_4 = 0b1000
	{
		goto rs_scale2;
	}


# CACHE/CACHEE op, offset(rs)
# TODO "Requires CP0 privilege, availability varies by format."

## CACHE
:CACHE rt_raw, lo_soffset9(rs) is
	hi_pool10_6 = 0b101001 & rt_raw & rs;
	lo_pool11_4 = 0b0111 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b01 & lo_soffset9
	unimpl

## CACHEE, present when Config5.EVA=1.
:CACHEE rt_raw, lo_soffset9(rs) is
	hi_pool10_6 = 0b101001 & rt_raw & rs;
	lo_pool11_4 = 0b0111 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10 & lo_soffset9
	unimpl

# CLO rt, rs
:CLO rt, rs is
	hi_pool10_6 = 0b001000 & rt & rs;
	lo_pool9_7 = 0b0100101 & lo_pool6_3 = 0b100 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	{
		# count leading 1s
		rt = lzcount(~rs);
	}

# CLZ
## CLZ rt, rs
:CLZ rt, rs is
	hi_pool10_6 = 0b001000 & rt & rs;
	rd & lo_pool9_7 = 0b0101101 & lo_pool6_3 = 0b100 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	{
		rt = lzcount(rs);
	}


# CRC32B
## CRC32B rt, rs
:CRC32B rt, rs is
	hi_pool10_6 = 0b001000 & rt & rs;
	lo_pool10_3 = 0b000 & lo_pool6_4 = 0b1111 & lo_pool5_1 = 0b1 & lo_pool3_2 = 0b01 & lo_pool0_3 = 0b000
	unimpl

# CRC32CB
## CRC32CB rt, rs
:CRC32CB rt, rs is
	hi_pool10_6 = 0b001000 & rt & rs;
	lo_pool10_3 = 0b100 & lo_pool6_4 = 0b1111 & lo_pool5_1 = 0b1 & lo_pool3_2 = 0b01 & lo_pool0_3 = 0b000
	unimpl

# CRC32CH
## CRC32CH rt, rs
:CRC32CH rt, rs is
	hi_pool10_6 = 0b001000 & rt & rs;
	lo_pool10_3 = 0b101 & lo_pool6_4 = 0b1111 & lo_pool5_1 = 0b1 & lo_pool3_2 = 0b01 & lo_pool0_3 = 0b000
	unimpl

# CRC32CW
## CRC32CW rt, rs
:CRC32CW rt, rs is
	hi_pool10_6 = 0b001000 & rt & rs;
	lo_pool10_3 = 0b110 & lo_pool6_4 = 0b1111 & lo_pool5_1 = 0b1 & lo_pool3_2 = 0b01 & lo_pool0_3 = 0b000
	unimpl

# CRC32H
## CRC32H rt, rs
:CRC32H rt, rs is
	hi_pool10_6 = 0b001000 & rt & rs;
	lo_pool10_3 = 0b001 & lo_pool6_4 = 0b1111 & lo_pool5_1 = 0b1 & lo_pool3_2 = 0b01 & lo_pool0_3 = 0b000
	unimpl

# CRC32W
## CRC32W rt, rs
:CRC32W rt, rs is
	hi_pool10_6 = 0b001000 & rt & rs;
	lo_pool10_3 = 0b010 & lo_pool6_4 = 0b1111 & lo_pool5_1 = 0b1 & lo_pool3_2 = 0b01 & lo_pool0_3 = 0b000
	unimpl


# DERET
## DERET rt, rs
:DERET is
	hi_pool10_6 = 0b001000;
	lo_pool14_2 = 0b11 & lo_pool9_5 = 0b10001 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	unimpl

# DI
## DI rt
:DI is
	hi_pool10_6 = 0b001000 & rt;
	lo_pool14_2 = 0b01 & lo_pool9_5 = 0b00011 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	unimpl

# DIV
## DIV rd, rs, rt
:DIV is
	hi_pool10_6 = 0b001000 & rt & rs;
	rd & lo_pool3_7 = 0b0100011 & lo_pool0_3 = 0b000
	{
		# TODO: Verify correct to sign extend for 32 bit value
		# TODO: implement signedness
		rd = sext(rs / rt);
	}

# DIVU
## DIVU rd, rs, rt
:DIVU is
	hi_pool10_6 = 0b001000 & rt & rs;
	rd & lo_pool3_7 = 0b0110011 & lo_pool0_3 = 0b000
	{
		rd = sext(rs / rt);
	}

# DVP
## DVP rt
:DVP is
	hi_pool10_6 = 0b001000 & rt;
	lo_pool11_5 = 0b00000 & lo_pool10_1 = 0b0 & lo_pool3_7 = 0b1110010 & lo_pool0_3 = 0b000
	unimpl  # NOTE: not sure how to handle coprocessor instructions


# EHB
## EHB
:EHB is
	hi_pool10_6 = 0b001000 & hi_pool5_5 = 0b00000;
	lo_pool12_4 = 0b1100  & lo_pool5_4 = 0b0000 & lo_pool0_5 = 0b00011
	unimpl  # NOTE: not sure how to handle coprocessor instructions


# EI
## EI rt
:EI rt is
	hi_pool10_6 = 0b001000 & rt;
	lo_pool14_2 = 0b01 & lo_pool9_5 = 0b01011 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	unimpl # NOTE: not sure how to handle coprocessor instructions


# ERET
## ERET
:ERET is
	hi_pool10_6 = 0b001000 & hi_pool0_1 = 0b0;
	lo_pool14_2 = 0b11 & lo_pool9_5 = 0b11001 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	unimpl  # NOTE: not sure how to handle coprocessor instructions


# ERETNC
## ERETNC
:ERETNC is
	hi_pool10_6 = 0b001000 & hi_pool0_1 = 0b1;
	lo_pool14_2 = 0b11 & lo_pool9_5 = 0b11001  & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	unimpl  # NOTE: not sure how to handle coprocessor instructions


# EVP
## EVP rt
:EVP rt is
	hi_pool10_6 = 0b001000 & rt;
	lo_pool11_5 = 0b00000  & lo_pool10_1 = 0b1 & lo_pool3_7 = 0b1110010 & lo_pool0_3 = 0b000
	unimpl  # NOTE: not sure how to handle coprocessor instructions


# EXT ()
## EXT rt, rs, pos, size
#:EXT rt is hi_pool10_6 = 0b001000 & rt ; lo_pool14_2 = 0b01  & lo_pool9_5 = 0b01011 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111 {
#	# NOTE: not sure how to handle coprocessor instructions
#}

# EXTW()
## EVP rt, rs, pos, size
#:EVP rt is hi_pool10_6 = 0b001000 & rt ; lo_pool14_2 = 0b01  & lo_pool9_5 = 0b01011 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111 {
#	# NOTE: not sure how to handle coprocessor instructions
#}

# GINV()
## GINV rt
:GINV rs is
	hi_pool10_6 = 0b001000 & rs;
	lo_pool14_2 = 0b00  & lo_pool9_5 = 0b01111 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	unimpl  # NOTE: not sure how to handle coprocessor instructions

# GINVT()
## GINVT rt
#:GINV rt is hi_pool10_6 = 0b001000 & rt ; lo_pool14_2 = 0b01  & lo_pool9_5 = 0b01011 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111 {
#	# NOTE: not sure how to handle coprocessor instructions
#}


# INS rt, rs, pos, size
:INS rt, rs, lo_uimm0_5, sz is
	hi_pool10_6 = 0b100000 & rt & rs;
	lo_pool12_4 = 0b1110 & lo_pool11_1 = 0b0 & lo_uimm6_5 & lo_pool5_1 = 0b0 & lo_uimm0_5
	[
		sz = 1 + lo_uimm6_5 - lo_uimm0_5;
	]
	{
		local pos = lo_uimm0_5;
		local merge_mask:4 = ((1 << sz) - 1) << pos;
		local result:4 = (rt & ~merge_mask) | ((rs << pos) & merge_mask);
		rt = sext(result);
	}


# JALRC dst, src
## JALRC[32]
:JALRC rt, rs is
	hi_pool10_6 = 0b010010 & rt & rs;
	lo_pool12_4 = 0b0000
	{
		rt = inst_next;
		call [rs];
	}

## JALRC[16]
:JALRC ra, rt is
	hi_pool10_6 = 0b110110 & rt & hi_pool4_1 = 0b1 & hi_pool0_4 = 0b0000 & ra
	{
		ra = inst_next;
		call [rt];
	}


# JRC
:JRC rt is
	hi_pool10_6 = 0b110110 & rt & hi_pool4_1 = 0 & hi_pool0_4 = 0b0000
	{
		goto [rt];
	}


# LB rt, offset(rs)
## LB[U12]
:LB rt, lo_rs_uoffset12 is
	(hi_pool10_6 = 0b100001 & rt;
	lo_pool12_4 = 0b0000)
	& lo_rs_uoffset12
	{
		rt = sext(*:1 lo_rs_uoffset12);
	}

## LB[16]
:LB rt3, hi_rs3_uoffset2 is
	hi_pool10_6 = 0b010111 & rt3 & hi_rs3_uoffset2
	{
		rt3 = sext(*:1 hi_rs3_uoffset2);
	}

## LB[GP]
:LB rt, hilo_gp_uoffset18 is
	(hi_pool10_6 = 0b010001 & rt & hi_pool2_3 = 0b000) ... & hilo_gp_uoffset18
	{
		rt = sext(*:1 hilo_gp_uoffset18);
	}

## LB[S9]
:LB rt, lo_rs_soffset9 is
	(hi_pool10_6 = 0b101001 & rt;
	lo_pool11_4 = 0b0000 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b00)
	& lo_rs_soffset9
	{
		rt = (*:1 lo_rs_soffset9);
	}


# LBE
## LBE rt, offset(rs)
:LBE rt, lo_rs_soffset9 is
	(hi_pool10_6 = 0b101001 & rt;
	lo_pool11_4 = 0b0000 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10)
	& lo_rs_soffset9 
	{
		rt = sext(*:1 lo_rs_soffset9);
	}

# LBU
## LBU rt, offset(rs)
:LBU rt, lo_rs_uoffset12 is 
	(hi_pool10_6 = 0b100001 & rt;
	lo_pool12_4 = 0b0010)
	& lo_rs_uoffset12
	{
		rt = (*:1 lo_rs_uoffset12);
	}

# LBU
## LBU[16] rt3, offset(rs3)
:LBU rt3, hi_rs3_uoffset2 is
	(hi_pool10_6 = 0b010111 & rt3 & hi_pool2_2 = 0b10)
	& hi_rs3_uoffset2
	{
		rt3 = (*:1 hi_rs3_uoffset2);
	}

## LBU[GP]
:LBU rt, hilo_gp_uoffset18 is
	(hi_pool10_6 = 0b010001 & rt & hi_pool2_3 = 0b010) ... & hilo_gp_uoffset18
	{
		rt = (*:1 hilo_gp_uoffset18);
	}

## LBU[S9]
:LBU rt, lo_rs_soffset9 is
	(hi_pool10_6 = 0b101001 & rt;
	lo_pool11_4 = 0b0010 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b00)
	& lo_rs_soffset9
	{
		rt = (*:1 lo_rs_soffset9);
	}

# LBUE
## LBUE rt, offset(rs)
:LBUE rt, lo_rs_soffset9 is
	(hi_pool10_6 = 0b101001 & rt;
	lo_pool11_4 = 0b0010 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10)
	& lo_rs_soffset9
	{
		rt = (*:1 lo_rs_soffset9);
	}

# LBUX
## LBUX rd, rs(rt)
:LBUX rd, rt_offset_rs is
	(hi_pool10_6 = 0b001000 & rt_offset_rs;
	rd  & lo_pool7_4 = 0b0010 & lo_pool6_1 = 0b0 & lo_pool3_3 = 0b000 & lo_pool0_3 = 0b111)
	{
		rd = (*:1 rt_offset_rs);
	}

# LBX
## LBX rt, offset(rs)
:LBUX rd, rt_offset_rs is
	(hi_pool10_6 = 0b001000 & rt_offset_rs;
	rd  & lo_pool7_4 = 0b0000 & lo_pool6_1 = 0b0 & lo_pool3_3 = 0b000 & lo_pool0_3 = 0b111)
	{
		rd = (*:1 rt_offset_rs);
	}


# LH rt, offset(rs)
## LH[U12]
:LH rt, lo_rs_uoffset12 is
	(hi_pool10_6 = 0b100001 & rt;
	lo_pool12_4 = 0b0100)
	& lo_rs_uoffset12
	{
		rt = sext(*:2 lo_rs_uoffset12);
	}

## LH[16]
:LH rt3, hi_rs3_uoffset2 is
	(hi_pool10_6 = 0b011111 & rt3 & hi_pool3_1 = 0b0 & hi_pool0_1 = 0b0)
	& hi_rs3_uoffset2
	{
		# TODO: make the number and also reference original example maybe
		rt3 = sext(*:2 hi_rs3_uoffset2);
	}

# LH
## LH rt, offset(gp)
:LH rt, lo_pool1_15(gp) is hi_pool10_6 = 0b100001 & rt & hi_pool2_3 = 0b100 & hi_pool0_2; lo_pool1_15 & lo_pool0_1 = 0b0 & gp{
	#rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
	#TODO: Need to reference the uim12 example provided by LB
}

# LH
## LH rt, offset(s9)
:LH rt, lo_pool0_8(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b0100 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b00 & lo_pool0_8 {
	#rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
}

# LHE
## LHE rt, offset(rs)
:LHE rt, lo_pool0_8(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b0100 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10 & lo_pool0_8 {
	#rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
}

# LHU
## LHU[u12] rt, offset(rs)
:LHU rt, lo_uimm0_12(rs) is hi_pool10_6 = 0b100001 & rt & rs; lo_pool12_4 = 0b0110 & lo_uimm0_12 {
	rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
}

# LHU
## LHU[16] rt, offset(rs)
:LHU rt3, hi_pool1_2(rs3) is hi_pool10_6 = 0b011111 & rt3 & rs3 & hi_pool3_1 = 0b1 & hi_pool1_2 & hi_pool0_1 = 0b0  {
	# TODO: make the number and also reference original example maybe
	rt3 = *(rs3 + hi_pool1_2); # TODO: currently updating this to be correct, this is not correct atm
}

# LHU
## LHU[GP] rt, offset(rs)
:LHU rt, lo_pool1_15(gp) is hi_pool10_6 = 0b100001 & rt & hi_pool2_3 = 0b100 & hi_pool0_2; lo_pool1_15 & lo_pool0_1 = 0b1 & gp{
	#rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
	#TODO: Need to reference the uim12 example provided by LB
}

# LHU
## LHU[S9] rt, offset(rs)
:LHU rt, lo_pool0_8(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b0110 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b00 & lo_pool0_8 {
	#rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
}

# LHUE
## LHUE rt, offset(rs)
:LHUE rt, lo_pool0_8(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b0110 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10 & lo_pool0_8 {
	#rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
}
# LHUX
## LHUX rt, offset(rs)
:LHUX rd, rs(rt) is hi_pool10_6 = 0b001000 & rt & rs; rd  & lo_pool7_4 = 0b0110 & lo_pool6_1 = 0b0 & lo_pool3_3 = 0b000 & lo_pool0_3 = 0b111 {
	# NOTE: not sure how to handle coprocessor instructions
}

# LHUXS
## LHUXS rt, offset(rs)
:LHUXS rd, rs(rt) is hi_pool10_6 = 0b001000 & rt & rs; rd  & lo_pool7_4 = 0b0110 & lo_pool6_1 = 0b1 & lo_pool3_3 = 0b000 & lo_pool0_3 = 0b111 {
	# NOTE: not sure how to handle coprocessor instructions
}

# LHX
## LHX rt, offset(rs)
:LHX rd, rs(rt) is hi_pool10_6 = 0b001000 & rt & rs; rd  & lo_pool7_4 = 0b0100 & lo_pool6_1 = 0b0 & lo_pool3_3 = 0b000 & lo_pool0_3 = 0b111 {
	# NOTE: not sure how to handle coprocessor instructions
}

# LHXS
## LHXS rt, offset(rs)
:LHXS rd, rs(rt) is hi_pool10_6 = 0b001000 & rt & rs; rd  & lo_pool7_4 = 0b0100 & lo_pool6_1 = 0b1 & lo_pool3_3 = 0b000 & lo_pool0_3 = 0b111 {
	# NOTE: not sure how to handle coprocessor instructions
}

# LI
## LI[16]
:LI rt3, s is hi_pool10_6 = 0b110100 & rt3 & eu_imm7 = 127 [s = -1;] {
	rt3 = s;
}

:LI rt3, eu_imm7 is hi_pool10_6 = 0b110100 & rt3 & eu_imm7 {
	rt3 = eu_imm7;
} 

## LI[48]
:LI rt, s32 is hi_pool10_6 = 0b011000 & rt & hi_pool0_5 = 0b00000; lo_imm16; hi_imm16 [s32 = (hi_imm16 << 16) | lo_imm16;] {
	rt = s32;
	# TODO: is signedness maintained correctly?
}

# LL
## LL rt, offset(rs)
:LL rt, lo_pool2_6(rs) is hi_pool10_6 = 0b101001  & rt & rs ; lo_pool15_1 & lo_pool11_4 = 0b1010  & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b01 & lo_pool2_6 & lo_pool0_2 = 0b00 {
	# TODO: chage lo_pool to usim
	# TODO: complete loading functionality
}

# LLE
## LLE rt, offset(rs)
:LLE rt, lo_pool2_6(rs) is hi_pool10_6 = 0b101001  & rt & rs ; lo_pool15_1 & lo_pool11_4 = 0b1010  & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10 & lo_pool2_6 & lo_pool0_2 = 0b00 {
	# TODO: chage lo_pool to usim
	# TODO: complete loading functionality
}

# LLWP
## LLWP rt, offset(rs)
:LLWP rt, lo_pool3_5(rs) is hi_pool10_6 = 0b101001  & rt & rs ; lo_pool11_4 = 0b1010  & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b01 & lo_pool3_5 & lo_pool0_2 = 0b01 {
	# TODO: chage lo_pool to usim
	# TODO: complete loading functionality
}

# LLWPE
## LLWPE rt, offset(rs)
:LLWPE rt, lo_pool3_5(rs) is hi_pool10_6 = 0b101001  & rt & rs ; lo_pool11_4 = 0b1010  & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10 & lo_pool3_5 & lo_pool0_2 = 0b01 {
	# TODO: chage lo_pool to usim
	# TODO: complete loading functionality
}

# LSA
## LSA rd, rs, rt, u2
:LHXS rd, rs, rt, lo_pool9_2 is hi_pool10_6 = 0b001000 & rt & rs; rd  & lo_pool9_2 & lo_pool3_3 = 0b001 & lo_pool0_3 = 0b111 {
	# NOTE: finsish the operation
}


# LUI rt, %hi(imm)
:LUI rt, "%hi"(hilo_simm32) is
	(hi_pool10_6 = 0b111000 & rt;
	lo_pool1_1 = 0b0)
	& hilo_simm32
	{
		rt = hilo_simm32;
	}


# LW rt, offset(rs)
## LW[U12]
:LW rt, lo_rs_uoffset12 is
	(hi_pool10_6 = 0b100001 & rt & rs;
	lo_pool12_4 = 0b1000)
	& lo_rs_uoffset12
	{
		rt = *:4 lo_rs_uoffset12;
	}

## LW[16]
:LW rt3, hi_rs3_uoffset6 is
	hi_pool10_6 = 0b000101 & rt3 & hi_rs3_uoffset6
	{
		rt3 = *:4 hi_rs3_uoffset6;
	}

## LW[4X4], not available in NMS
:LW rt4, hi_rs4_uoffset4 is
	hi_pool10_6 = 0b011101 & rt4 & hi_rs4_uoffset4
	{
		rt4 = *:4 hi_rs4_uoffset4;
	}

## LW[GP16]
:LW rt3, hi_gp_uoffset9 is
	hi_pool10_6 = 0b010101 & rt3 & hi_gp_uoffset9
	{
		rt3 = *:4 hi_gp_uoffset9;
	}

## LW[GP]
:LW rt, hilo_gp_uoffset21 is
	(hi_pool10_6 = 0b010000 & rt) ... & hilo_gp_uoffset21
	{
		rt = *:4 hilo_gp_uoffset21;
	}

## LW[S9]
:LW rt, lo_rs_soffset9 is
	(hi_pool10_6 = 0b101001 & rt;
	lo_pool11_4 = 0b1000 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b00)
	& lo_rs_soffset9
	{
		rt = *:4 lo_rs_soffset9;
	}

## LW[SP]
:LW rt, hi_sp_uoffset7 is
	hi_pool10_6 = 0b001101 & rt & hi_sp_uoffset7
	{
		rt = *:4 hi_sp_uoffset7;
	}


# LWE rt, offset(rs)
:LWE rt, lo_rs_soffset9 is
	(hi_pool10_6 = 0b101001 & rt;
	lo_pool11_4 = 0b1000 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10)
	& lo_rs_soffset9
	{
		# TODO EVA addressing mode
		rt = *:4 lo_rs_soffset9;
	}


# LWM rt, offset(rs), count
:LWM rt, lo_rs_soffset9, count3 is
	(hi_pool10_6 = 0b101001 & rt;
	count3 & lo_pool11_1 = 0b0 & lo_pool10_1 = 0b1 & lo_pool8_2 = 0b00)
	& lo_rs_soffset9
	unimpl


# LWPC rt, address
## LWPC[48]
:LWPC rt, pc_rel_saddr32 is
	hi_pool10_6 = 0b011000 & rt & hi_pool0_5 = 0b01011;
	pc_rel_saddr32
	{
		rt = *:4 pc_rel_saddr32;
	}


# LWX rd, rs(rt)
:LWX rd, rt_offset_rs is
	hi_pool10_6 = 0b001000 & rt_offset_rs;
	rd & lo_pool7_4 = 0b1000 & lo_pool6_1 = 0b0 & lo_pool3_3 = 0b000 & lo_pool0_3 = 0b111
	{
		rd = *:4 rt_offset_rs;
	}


# LWXS rd, rs(rt)
## LWXS[32]
:LWXS rd, rt_offset_4rs is
	hi_pool10_6 = 0b001000 & rt_offset_4rs;
	rd & lo_pool7_4 = 0b1000 & lo_pool6_1 = 0b1 & lo_pool3_3 = 0b000 & lo_pool0_3 = 0b111
	{
		rd = *:4 rt_offset_4rs;
	}

## LWXS[16]
:LWXS rd3, rt3_offset_4rs3 is
	hi_pool10_6 = 0b010100 & rd3 & rt3_offset_4rs3 & hi_pool0_1 = 0b1
	{
		rd3 = *:4 rt3_offset_4rs3;
	}


# MFC0 rt, c0s, sel
:MFC0 rt, c0s, sel is
	hi_pool10_6 = 0b001000 & rt & c0s;
	sel & lo_pool3_7 = 0b0000110 & lo_pool0_3 = 0b000
	unimpl


# MFHC0 rt, c0s, sel
:MFHC0 rt, c0s, sel is
	hi_pool10_6 = 0b001000 & rt & c0s;
	sel & lo_pool3_7 = 0b0000111 & lo_pool0_3 = 0b000
	unimpl


# MOD
## MOD rd, rs, rt
:MOD rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0101011 & lo_pool0_3 = 0b000 {
	rd = rs % rt;
}

# MODU
## MOD rd, rs, rt
:MODU rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0111011 & lo_pool0_3 = 0b000 {
	# TODO :zero extend
	rd = rs % rt;
}


# MOVE rt, rs
:MOVE rt, rs is
	hi_pool10_6 = 0b000100 & rt & rt_raw != 0 & rs
	{
		rt = rs;
	}


# MOVE.BALC rd, rt, address
:MOVE.BALC rd1, rtz4, hilo_saddr22 is
	(hi_pool10_6 = 0b000010 & rtz4 & rd1) ... & hilo_saddr22
	{
		rd1 = rtz4;
		ra = inst_next;
		call hilo_saddr22;
	}


# MOVEP dst1, dst2, src1, src2
## MOVEP
:MOVEP rd2_reg1, rd2_reg2, rsz4, rtz4 is
	hi_pool10_6 = 0b101111 & rtz4 & rd2_reg1 & rd2_reg2 & rsz4
	{
		rd2_reg1 = rsz4;
		rd2_reg2 = rtz4;
	}

## MOVEP[REV]
:MOVEP rs4, rt4, rd2_reg1, rd2_reg2 is
	hi_pool10_6 = 0b111111 & rt4 & rd2_reg1 & rd2_reg2 & rs4
	{
		rs4 = rd2_reg1;
		rt4 = rd2_reg2;
	}


# MOVN
## MOVN rd, rs, rt
:MOVN rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool10_1 = 1 & lo_pool3_7 = 0b1000010 & lo_pool0_3 = 0b000 {
	#TODO: work out zero logic with rt
	rd = rs;
}

# MOVZ
## MOVZ rd, rs, rt
:MOVZ rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool10_1 = 0 & lo_pool3_7 = 0b1000010 & lo_pool0_3 = 0b000 {
	#TODO: work out zero logic with rt
	rd = rs;
}

# MTC0
## MTC0 rt, c0s, sel
:MTC0 rt, c0s, sel is hi_pool10_6 = 0b001000 & rt & c0s; sel & lo_pool3_7 = 0b0001110 & lo_pool0_3 = 0b000 {
	#TODO: read register and sign extend
}

# MTHC0
## MTHC0 rt, c0s, sel
:MTHC0 rt, c0s, sel is hi_pool10_6 = 0b001000 & rt & c0s; sel & lo_pool3_7 = 0b0001111 & lo_pool0_3 = 0b000 {
	#TODO: read register and sign extend
}

# MUH
## MUH rd, rs, rt
:MUH rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0001011 & lo_pool0_3 = 0b000 {
	rd = rs * rt;
}

# MUHU
## MUHU  rd, rs, rt
:MUHU rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0011011 & lo_pool0_3 = 0b000 {
	rd = rs * rt;
}

# MUL
## MUL rd, rs, rt
:MUL rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0000011 & lo_pool0_3 = 0b000 {
	rd = rs * rt;
}

# MULU
## MUL rd, rs, rt
:MULU rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0010011 & lo_pool0_3 = 0b000 {
	rd = rs * rt;
}

# NOP
## NOP
:NOP is hi_pool10_6 = 0b100000 & hi_pool5_5 = 0b00000; lo_pool12_4 = 0b1100 & lo_pool5_4 = 0b0000 & lo_pool0_5 = 0b00000 { }

# NOP
## NOP
:NOP is hi_pool10_6 = 0b100100 & hi_pool5_5 = 0b00000 & hi_pool3_1 = 0b0 { }

# NOR
## NOR rd, rs, rt
:NOR rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b1011010 & lo_pool0_3 = 0b000 {
	rt = ~(rs | rt);
}

# NOT
## NOT[16] rt, rs
:NOT rt3, rs3 is hi_pool10_6 = 0b001000 & rt3 & rs3 {
	rt3 = ~(rs3);
}


# OR rd, rs, rt
## OR[32]
:OR rd, rs, rt is
	hi_pool10_6 = 0b001000 & rt & rs;
	rd & lo_pool3_7 = 0b1010010 & lo_pool0_3 = 0b000
	{
		rd = rs | rt;
	}

## OR[16]
:OR rd3_from_rt3, rs3, rt3 is
	hi_pool10_6 = 0b010100 & rd3_from_rt3 & rt3 & rs3 & hi_pool2_2 = 0b11 & hi_pool1_1 = 0 & hi_pool0_1 = 0
	{
		rd3_from_rt3 = rs3 | rt3;
	}


# ORI
## OR rd, rs, rt
:ORI rt, rs, lo_uimm0_12 is hi_pool10_6 = 0b100000 & rt & rs; lo_pool12_4 = 0b0000 & lo_uimm0_12 {
	rt = rs | lo_uimm0_12;
}

# PAUSE
## PAUSE rd, rs, rt
:PAUSE is hi_pool10_6 = 0b100000 & hi_pool5_5 = 0b00000; lo_pool12_4 = 0b1100 & lo_pool5_4 = 0b0000 & lo_pool0_5 = 0b00101 unimpl

# PREF
## PREF hint, offset(rs)
## TODO: make a custom hint register
:PREF rt, lo_pool0_8(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b0011 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b00 & lo_pool0_8 {
	rt = *(rs + lo_pool0_8); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
}

# PREF
## PREF[U12[ hint, offset(rs)
## TODO: make a custom hint register
:PREF rt, lo_uimm0_12(rs) is hi_pool10_6 = 0b100001 & rt & rs; lo_pool12_4 = 0b0011 & lo_uimm0_12 {
	*(rs + lo_uimm0_12) = rt; # TODO: currently updating this to be correct, this is not correct atm
}

# PREFE
## PREFE hint, offset(rs)
## TODO: make a custom hint register
:PREFE rt, lo_pool0_8(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b0011 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10 & lo_pool0_8 {
	rt = *(rs + lo_pool0_8); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
}

# RDHWR ()
## RDHWR rd, rs, rt
#:RDHWR rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0000011 & lo_pool0_3 = 0b000 {
#	rd = rs * rt;
#}

# RDPGPR
## RDPGPR rd, rs, rt
:RDPGPR rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool14_2 = 0b11 & lo_pool9_5 = 0b10000 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111 unimpl


# RESTORE     u[, dst1 [, dst2 [, ...]]]  # jr=0 implied
# RESTORE.JRC u[, dst1 [, dst2 [, ...]]]  # jr=1 implied

## RESTORE.JRC[16]
reglist_rs16_15: sp			is count = 16 - rt1_raw & rt1_raw & sp & hi_uoffset8_sl4	{sp = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(16-rt1_raw));}
reglist_rs16_14: gp			is count = 15 - rt1_raw & rt1_raw & gp & hi_uoffset8_sl4	{gp = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(15-rt1_raw));}
reglist_rs16_14: gp,reglist_rs16_15	is rt1_raw & gp & reglist_rs16_15 & hi_uoffset8_sl4	{gp = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(15-rt1_raw));}
reglist_rs16_13: k1			is count = 14 - rt1_raw & rt1_raw & k1 & hi_uoffset8_sl4	{k1 = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(14-rt1_raw));}
reglist_rs16_13: k1,reglist_rs16_14	is rt1_raw & k1 & reglist_rs16_14 & hi_uoffset8_sl4	{k1 = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(14-rt1_raw));}
reglist_rs16_12: k0			is count = 13 - rt1_raw & rt1_raw & k0 & hi_uoffset8_sl4	{k0 = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(13-rt1_raw));}
reglist_rs16_12: k0,reglist_rs16_13	is rt1_raw & k0 & reglist_rs16_13 & hi_uoffset8_sl4	{k0 = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(13-rt1_raw));}
reglist_rs16_11: t9			is count = 12 - rt1_raw & rt1_raw & t9 & hi_uoffset8_sl4	{t9 = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(12-rt1_raw));}
reglist_rs16_11: t9,reglist_rs16_12	is rt1_raw & t9 & reglist_rs16_12 & hi_uoffset8_sl4	{t9 = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(12-rt1_raw));}
reglist_rs16_10: t8			is count = 11 - rt1_raw & rt1_raw & t8 & hi_uoffset8_sl4	{t8 = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(11-rt1_raw));}
reglist_rs16_10: t8,reglist_rs16_11	is rt1_raw & t8 & reglist_rs16_11 & hi_uoffset8_sl4	{t8 = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(11-rt1_raw));}
reglist_rs16_09: s7			is count = 10 - rt1_raw & rt1_raw & s7 & hi_uoffset8_sl4	{s7 = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(10-rt1_raw));}
reglist_rs16_09: s7,reglist_rs16_10	is rt1_raw & s7 & reglist_rs16_10 & hi_uoffset8_sl4	{s7 = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(10-rt1_raw));}
reglist_rs16_08: s6			is count = 9 - rt1_raw & rt1_raw & s6 & hi_uoffset8_sl4	{s6 = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(9-rt1_raw));}
reglist_rs16_08: s6,reglist_rs16_09	is rt1_raw & s6 & reglist_rs16_09 & hi_uoffset8_sl4	{s6 = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(9-rt1_raw));}
reglist_rs16_07: s5			is count = 8 - rt1_raw & rt1_raw & s5 & hi_uoffset8_sl4	{s5 = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(8-rt1_raw));}
reglist_rs16_07: s5,reglist_rs16_08	is rt1_raw & s5 & reglist_rs16_08 & hi_uoffset8_sl4	{s5 = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(8-rt1_raw));}
reglist_rs16_06: s4			is count = 7 - rt1_raw & rt1_raw & s4 & hi_uoffset8_sl4	{s4 = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(7-rt1_raw));}
reglist_rs16_06: s4,reglist_rs16_07	is rt1_raw & s4 & reglist_rs16_07 & hi_uoffset8_sl4	{s4 = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(7-rt1_raw));}
reglist_rs16_05: s3			is count = 6 - rt1_raw & rt1_raw & s3 & hi_uoffset8_sl4	{s3 = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(6-rt1_raw));}
reglist_rs16_05: s3,reglist_rs16_06	is rt1_raw & s3 & reglist_rs16_06 & hi_uoffset8_sl4	{s3 = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(6-rt1_raw));}
reglist_rs16_04: s2			is count = 5 - rt1_raw & rt1_raw & s2 & hi_uoffset8_sl4	{s2 = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(5-rt1_raw));}
reglist_rs16_04: s2,reglist_rs16_05	is rt1_raw & s2 & reglist_rs16_05 & hi_uoffset8_sl4	{s2 = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(5-rt1_raw));}
reglist_rs16_03: s1			is count = 4 - rt1_raw & rt1_raw & s1 & hi_uoffset8_sl4	{s1 = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(4-rt1_raw));}
reglist_rs16_03: s1,reglist_rs16_04	is rt1_raw & s1 & reglist_rs16_04 & hi_uoffset8_sl4	{s1 = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(4-rt1_raw));}
reglist_rs16_02: s0			is count = 3 - rt1_raw & rt1_raw & s0 & hi_uoffset8_sl4	{s0 = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(3-rt1_raw));}
reglist_rs16_02: s0,reglist_rs16_03	is rt1_raw & s0 & reglist_rs16_03 & hi_uoffset8_sl4	{s0 = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(3-rt1_raw));}
reglist_rs16_01: ra			is count = 2 - rt1_raw & rt1_raw & ra & hi_uoffset8_sl4	{ra = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(2-rt1_raw));}
reglist_rs16_01: ra,reglist_rs16_02	is rt1_raw & ra & reglist_rs16_02 & hi_uoffset8_sl4	{ra = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(2-rt1_raw));}
reglist_rs16_00: fp			is count = 1 - rt1_raw & rt1_raw & fp & hi_uoffset8_sl4	{fp = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(1-rt1_raw));}
reglist_rs16_00: fp,reglist_rs16_01	is rt1_raw & fp & reglist_rs16_01 & hi_uoffset8_sl4	{fp = *:$(REGSIZE) (sp + hi_uoffset8_sl4 - $(REGSIZE)*(1-rt1_raw));}
reglist_rs16: 			is count = 0 {}
reglist_rs16: ,reglist_rs16_01	is rt1_raw = 1 & reglist_rs16_01 {}
reglist_rs16: ,reglist_rs16_00	is rt1_raw = 0 & reglist_rs16_00 {}

:RESTORE.JRC hi_uoffset8_sl4^reglist_rs16 is
	hi_pool10_6 = 0b000111 & hi_pool8_1 = 0b1 & hi_uoffset8_sl4 & reglist_rs16
	{
		build reglist_rs16;
		# TODO effective_address
		sp = sp + hi_uoffset8_sl4;
		return [ra];
	}

## RESTORE[32]
:RESTORE is hi_pool10_6 = 0b100000  & rt & hi_pool4_1 = 0 & hi_pool0_4; lo_pool12_4 = 0b0011 & lo_pool3_9 & lo_pool2_1 & lo_pool0_2 = 0b10
unimpl

## RESTORE.JRC[32]
:RESTORE.JRC is hi_pool10_6 = 0b100000  & rt & hi_pool4_1 & hi_pool0_4; lo_pool12_4 = 0b0011 & lo_pool3_9 & lo_pool2_1 & lo_pool0_2 = 0b11
unimpl

# ROTR
## ROTR rd, rs, shift
:ROTR rt, rs, lo_pool0_5 is hi_pool10_6 = 0b100000 & rt & rs; lo_pool12_4 = 0b1100 & lo_pool5_4 = 0b0110 & lo_pool0_5 {
	# TODO: sign extend
	rt = rs >> lo_pool0_5;
}

# ROTRV
## ROTRV rd, rs, shift
:ROTRV rd, rs, rt is hi_pool10_6 = 0b100000 & rt & rs; rd & lo_pool3_7 = 0b0011010 & lo_pool0_3 = 0b000 {
	# TODO: complete operation
	# TODO: sign extend
	rd = rs >> rt;
}

# ROTX ()
## ROTX rd, rs, shift
#:ROTX rt, rs, lo_pool0_5 is hi_pool10_6 = 0b100000 & rt & rs; lo_pool12_4 = 0b1100 & lo_pool5_4 = 0b0110 & lo_pool0_5 {
#	# TODO: sign extend
#	rt = rs >> lo_pool0_5;
#}


# SAVE u[, src1 [, src2 [, ...]]]
## SAVE[16]
reglist_sv16_15: sp                     is count = 16 - rt1_raw & rt1_raw & sp  {*:$(REGSIZE) (sp - $(REGSIZE)*(16-rt1_raw)) = sp;}
reglist_sv16_14: gp                     is count = 15 - rt1_raw & rt1_raw & gp  {*:$(REGSIZE) (sp - $(REGSIZE)*(15-rt1_raw)) = gp;}
reglist_sv16_14: gp,reglist_sv16_15     is rt1_raw & gp & reglist_sv16_15       {*:$(REGSIZE) (sp - $(REGSIZE)*(15-rt1_raw)) = gp;}
reglist_sv16_13: k1                     is count = 14 - rt1_raw & rt1_raw & k1  {*:$(REGSIZE) (sp - $(REGSIZE)*(14-rt1_raw)) = k1;}
reglist_sv16_13: k1,reglist_sv16_14     is rt1_raw & k1 & reglist_sv16_14       {*:$(REGSIZE) (sp - $(REGSIZE)*(14-rt1_raw)) = k1;}
reglist_sv16_12: k0                     is count = 13 - rt1_raw & rt1_raw & k0  {*:$(REGSIZE) (sp - $(REGSIZE)*(13-rt1_raw)) = k0;}
reglist_sv16_12: k0,reglist_sv16_13     is rt1_raw & k0 & reglist_sv16_13       {*:$(REGSIZE) (sp - $(REGSIZE)*(13-rt1_raw)) = k0;}
reglist_sv16_11: t9                     is count = 12 - rt1_raw & rt1_raw & t9  {*:$(REGSIZE) (sp - $(REGSIZE)*(12-rt1_raw)) = t9;}
reglist_sv16_11: t9,reglist_sv16_12     is rt1_raw & t9 & reglist_sv16_12       {*:$(REGSIZE) (sp - $(REGSIZE)*(12-rt1_raw)) = t9;}
reglist_sv16_10: t8                     is count = 11 - rt1_raw & rt1_raw & t8  {*:$(REGSIZE) (sp - $(REGSIZE)*(11-rt1_raw)) = t8;}
reglist_sv16_10: t8,reglist_sv16_11     is rt1_raw & t8 & reglist_sv16_11       {*:$(REGSIZE) (sp - $(REGSIZE)*(11-rt1_raw)) = t8;}
reglist_sv16_09: s7                     is count = 10 - rt1_raw & rt1_raw & s7  {*:$(REGSIZE) (sp - $(REGSIZE)*(10-rt1_raw)) = s7;}
reglist_sv16_09: s7,reglist_sv16_10     is rt1_raw & s7 & reglist_sv16_10       {*:$(REGSIZE) (sp - $(REGSIZE)*(10-rt1_raw)) = s7;}
reglist_sv16_08: s6                     is count = 9 - rt1_raw & rt1_raw & s6   {*:$(REGSIZE) (sp - $(REGSIZE)*(9-rt1_raw)) = s6;}
reglist_sv16_08: s6,reglist_sv16_09     is rt1_raw & s6 & reglist_sv16_09       {*:$(REGSIZE) (sp - $(REGSIZE)*(9-rt1_raw)) = s6;}
reglist_sv16_07: s5                     is count = 8 - rt1_raw & rt1_raw & s5   {*:$(REGSIZE) (sp - $(REGSIZE)*(8-rt1_raw)) = s5;}
reglist_sv16_07: s5,reglist_sv16_08     is rt1_raw & s5 & reglist_sv16_08       {*:$(REGSIZE) (sp - $(REGSIZE)*(8-rt1_raw)) = s5;}
reglist_sv16_06: s4                     is count = 7 - rt1_raw & rt1_raw & s4   {*:$(REGSIZE) (sp - $(REGSIZE)*(7-rt1_raw)) = s4;}
reglist_sv16_06: s4,reglist_sv16_07     is rt1_raw & s4 & reglist_sv16_07       {*:$(REGSIZE) (sp - $(REGSIZE)*(7-rt1_raw)) = s4;}
reglist_sv16_05: s3                     is count = 6 - rt1_raw & rt1_raw & s3   {*:$(REGSIZE) (sp - $(REGSIZE)*(6-rt1_raw)) = s3;}
reglist_sv16_05: s3,reglist_sv16_06     is rt1_raw & s3 & reglist_sv16_06       {*:$(REGSIZE) (sp - $(REGSIZE)*(6-rt1_raw)) = s3;}
reglist_sv16_04: s2                     is count = 5 - rt1_raw & rt1_raw & s2   {*:$(REGSIZE) (sp - $(REGSIZE)*(5-rt1_raw)) = s2;}
reglist_sv16_04: s2,reglist_sv16_05     is rt1_raw & s2 & reglist_sv16_05       {*:$(REGSIZE) (sp - $(REGSIZE)*(5-rt1_raw)) = s2;}
reglist_sv16_03: s1                     is count = 4 - rt1_raw & rt1_raw & s1   {*:$(REGSIZE) (sp - $(REGSIZE)*(4-rt1_raw)) = s1;}
reglist_sv16_03: s1,reglist_sv16_04     is rt1_raw & s1 & reglist_sv16_04       {*:$(REGSIZE) (sp - $(REGSIZE)*(4-rt1_raw)) = s1;}
reglist_sv16_02: s0                     is count = 3 - rt1_raw & rt1_raw & s0   {*:$(REGSIZE) (sp - $(REGSIZE)*(3-rt1_raw)) = s0;}
reglist_sv16_02: s0,reglist_sv16_03     is rt1_raw & s0 & reglist_sv16_03       {*:$(REGSIZE) (sp - $(REGSIZE)*(3-rt1_raw)) = s0;}
reglist_sv16_01: ra                     is count = 2 - rt1_raw & rt1_raw & ra   {*:$(REGSIZE) (sp - $(REGSIZE)*(2-rt1_raw)) = ra;}
reglist_sv16_01: ra,reglist_sv16_02     is rt1_raw & ra & reglist_sv16_02       {*:$(REGSIZE) (sp - $(REGSIZE)*(2-rt1_raw)) = ra;}
reglist_sv16_00: fp                     is count = 1 - rt1_raw & rt1_raw & fp   {*:$(REGSIZE) (sp - $(REGSIZE)*(1-rt1_raw)) = fp;}
reglist_sv16_00: fp,reglist_sv16_01     is rt1_raw & fp & reglist_sv16_01       {*:$(REGSIZE) (sp - $(REGSIZE)*(1-rt1_raw)) = fp;}
reglist_sv16:                           is count = 0 {}
reglist_sv16:    ,reglist_sv16_01       is rt1_raw = 1 & reglist_sv16_01 {}
reglist_sv16:    ,reglist_sv16_00       is rt1_raw = 0 & reglist_sv16_00 {}

:SAVE hi_uoffset8_sl4^reglist_sv16 is
	hi_pool10_6 = 0b000111 & hi_pool8_1 = 0 & hi_uoffset8_sl4 & reglist_sv16
	{
		build reglist_sv16;
		# TODO effective_address
		sp = sp - hi_uoffset8_sl4;
	}

## SAVE[32] u, [ src1 [, src2 [ ..,]]
reglist_sv32_45: gp					is count = 46 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(46-rt_raw)) = gp;}
reglist_sv32_45: sp					is count = 46 - rt_raw & rt_raw & sp; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(46-rt_raw)) = sp;}
reglist_sv32_44: gp					is count = 45 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(45-rt_raw)) = gp;}
reglist_sv32_44: gp					is count = 45 - rt_raw & rt_raw & gp; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(45-rt_raw)) = gp;}
reglist_sv32_44: gp,reglist_sv32_45	is rt_raw ... & reglist_sv32_45 & gp				{*:$(REGSIZE) (sp - $(REGSIZE)*(45-rt_raw)) = gp;}
reglist_sv32_43: gp					is count = 44 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(44-rt_raw)) = gp;}
reglist_sv32_43: k1					is count = 44 - rt_raw & rt_raw & k1; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(44-rt_raw)) = k1;}
reglist_sv32_43: k1,reglist_sv32_44	is rt_raw ... & reglist_sv32_44 & k1				{*:$(REGSIZE) (sp - $(REGSIZE)*(44-rt_raw)) = k1;}
reglist_sv32_42: gp					is count = 43 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(43-rt_raw)) = gp;}
reglist_sv32_42: k0					is count = 43 - rt_raw & rt_raw & k0; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(43-rt_raw)) = k0;}
reglist_sv32_42: k0,reglist_sv32_43	is rt_raw ... & reglist_sv32_43 & k0				{*:$(REGSIZE) (sp - $(REGSIZE)*(43-rt_raw)) = k0;}
reglist_sv32_41: gp					is count = 42 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(42-rt_raw)) = gp;}
reglist_sv32_41: t9					is count = 42 - rt_raw & rt_raw & t9; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(42-rt_raw)) = t9;}
reglist_sv32_41: t9,reglist_sv32_42	is rt_raw ... & reglist_sv32_42 & t9				{*:$(REGSIZE) (sp - $(REGSIZE)*(42-rt_raw)) = t9;}
reglist_sv32_40: gp					is count = 41 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(41-rt_raw)) = gp;}
reglist_sv32_40: t8					is count = 41 - rt_raw & rt_raw & t8; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(41-rt_raw)) = t8;}
reglist_sv32_40: t8,reglist_sv32_41	is rt_raw ... & reglist_sv32_41 & t8				{*:$(REGSIZE) (sp - $(REGSIZE)*(41-rt_raw)) = t8;}
reglist_sv32_39: gp					is count = 40 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(40-rt_raw)) = gp;}
reglist_sv32_39: s7					is count = 40 - rt_raw & rt_raw & s7; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(40-rt_raw)) = s7;}
reglist_sv32_39: s7,reglist_sv32_40	is rt_raw ... & reglist_sv32_40 & s7				{*:$(REGSIZE) (sp - $(REGSIZE)*(40-rt_raw)) = s7;}
reglist_sv32_38: gp					is count = 39 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(39-rt_raw)) = gp;}
reglist_sv32_38: s6					is count = 39 - rt_raw & rt_raw & s6; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(39-rt_raw)) = s6;}
reglist_sv32_38: s6,reglist_sv32_39	is rt_raw ... & reglist_sv32_39 & s6				{*:$(REGSIZE) (sp - $(REGSIZE)*(39-rt_raw)) = s6;}
reglist_sv32_37: gp					is count = 38 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(38-rt_raw)) = gp;}
reglist_sv32_37: s5					is count = 38 - rt_raw & rt_raw & s5; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(38-rt_raw)) = s5;}
reglist_sv32_37: s5,reglist_sv32_38	is rt_raw ... & reglist_sv32_38 & s5				{*:$(REGSIZE) (sp - $(REGSIZE)*(38-rt_raw)) = s5;}
reglist_sv32_36: gp					is count = 37 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(37-rt_raw)) = gp;}
reglist_sv32_36: s4					is count = 37 - rt_raw & rt_raw & s4; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(37-rt_raw)) = s4;}
reglist_sv32_36: s4,reglist_sv32_37	is rt_raw ... & reglist_sv32_37 & s4				{*:$(REGSIZE) (sp - $(REGSIZE)*(37-rt_raw)) = s4;}
reglist_sv32_35: gp					is count = 36 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(36-rt_raw)) = gp;}
reglist_sv32_35: s3					is count = 36 - rt_raw & rt_raw & s3; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(36-rt_raw)) = s3;}
reglist_sv32_35: s3,reglist_sv32_36	is rt_raw ... & reglist_sv32_36 & s3				{*:$(REGSIZE) (sp - $(REGSIZE)*(36-rt_raw)) = s3;}
reglist_sv32_34: gp					is count = 35 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(35-rt_raw)) = gp;}
reglist_sv32_34: s2					is count = 35 - rt_raw & rt_raw & s2; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(35-rt_raw)) = s2;}
reglist_sv32_34: s2,reglist_sv32_35	is rt_raw ... & reglist_sv32_35 & s2				{*:$(REGSIZE) (sp - $(REGSIZE)*(35-rt_raw)) = s2;}
reglist_sv32_33: gp					is count = 34 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(34-rt_raw)) = gp;}
reglist_sv32_33: s1					is count = 34 - rt_raw & rt_raw & s1; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(34-rt_raw)) = s1;}
reglist_sv32_33: s1,reglist_sv32_34	is rt_raw ... & reglist_sv32_34 & s1				{*:$(REGSIZE) (sp - $(REGSIZE)*(34-rt_raw)) = s1;}
reglist_sv32_32: gp					is count = 33 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(33-rt_raw)) = gp;}
reglist_sv32_32: s0					is count = 33 - rt_raw & rt_raw & s0; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(33-rt_raw)) = s0;}
reglist_sv32_32: s0,reglist_sv32_33	is rt_raw ... & reglist_sv32_33 & s0				{*:$(REGSIZE) (sp - $(REGSIZE)*(33-rt_raw)) = s0;}
reglist_sv32_31: gp					is count = 32 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(32-rt_raw)) = gp;}
reglist_sv32_31: ra					is count = 32 - rt_raw & rt_raw & ra; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(32-rt_raw)) = ra;}
reglist_sv32_31: ra,reglist_sv32_32	is rt_raw ... & reglist_sv32_32 & ra				{*:$(REGSIZE) (sp - $(REGSIZE)*(32-rt_raw)) = ra;}
reglist_sv32_30: gp					is count = 31 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(31-rt_raw)) = gp;}
reglist_sv32_30: fp					is count = 31 - rt_raw & rt_raw & fp; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(31-rt_raw)) = fp;}
reglist_sv32_30: fp,reglist_sv32_31	is rt_raw ... & reglist_sv32_31 & fp				{*:$(REGSIZE) (sp - $(REGSIZE)*(31-rt_raw)) = fp;}
reglist_sv32_29: gp					is count = 30 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(30-rt_raw)) = gp;}
reglist_sv32_29: sp					is count = 30 - rt_raw & rt_raw & sp; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(30-rt_raw)) = sp;}
reglist_sv32_29: sp,reglist_sv32_30	is rt_raw ... & reglist_sv32_30 & sp				{*:$(REGSIZE) (sp - $(REGSIZE)*(30-rt_raw)) = sp;}
reglist_sv32_28: gp					is count = 29 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(29-rt_raw)) = gp;}
reglist_sv32_28: gp					is count = 29 - rt_raw & rt_raw & gp; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(29-rt_raw)) = gp;}
reglist_sv32_28: gp,reglist_sv32_29	is rt_raw ... & reglist_sv32_29 & gp				{*:$(REGSIZE) (sp - $(REGSIZE)*(29-rt_raw)) = gp;}
reglist_sv32_27: gp					is count = 28 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(28-rt_raw)) = gp;}
reglist_sv32_27: k1					is count = 28 - rt_raw & rt_raw & k1; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(28-rt_raw)) = k1;}
reglist_sv32_27: k1,reglist_sv32_28	is rt_raw ... & reglist_sv32_28 & k1				{*:$(REGSIZE) (sp - $(REGSIZE)*(28-rt_raw)) = k1;}
reglist_sv32_26: gp					is count = 27 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(27-rt_raw)) = gp;}
reglist_sv32_26: k0					is count = 27 - rt_raw & rt_raw & k0; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(27-rt_raw)) = k0;}
reglist_sv32_26: k0,reglist_sv32_27	is rt_raw ... & reglist_sv32_27 & k0				{*:$(REGSIZE) (sp - $(REGSIZE)*(27-rt_raw)) = k0;}
reglist_sv32_25: gp					is count = 26 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(26-rt_raw)) = gp;}
reglist_sv32_25: t9					is count = 26 - rt_raw & rt_raw & t9; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(26-rt_raw)) = t9;}
reglist_sv32_25: t9,reglist_sv32_26	is rt_raw ... & reglist_sv32_26 & t9				{*:$(REGSIZE) (sp - $(REGSIZE)*(26-rt_raw)) = t9;}
reglist_sv32_24: gp					is count = 25 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(25-rt_raw)) = gp;}
reglist_sv32_24: t8					is count = 25 - rt_raw & rt_raw & t8; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(25-rt_raw)) = t8;}
reglist_sv32_24: t8,reglist_sv32_25	is rt_raw ... & reglist_sv32_25 & t8				{*:$(REGSIZE) (sp - $(REGSIZE)*(25-rt_raw)) = t8;}
reglist_sv32_23: gp					is count = 24 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(24-rt_raw)) = gp;}
reglist_sv32_23: s7					is count = 24 - rt_raw & rt_raw & s7; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(24-rt_raw)) = s7;}
reglist_sv32_23: s7,reglist_sv32_24	is rt_raw ... & reglist_sv32_24 & s7				{*:$(REGSIZE) (sp - $(REGSIZE)*(24-rt_raw)) = s7;}
reglist_sv32_22: gp					is count = 23 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(23-rt_raw)) = gp;}
reglist_sv32_22: s6					is count = 23 - rt_raw & rt_raw & s6; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(23-rt_raw)) = s6;}
reglist_sv32_22: s6,reglist_sv32_23	is rt_raw ... & reglist_sv32_23 & s6				{*:$(REGSIZE) (sp - $(REGSIZE)*(23-rt_raw)) = s6;}
reglist_sv32_21: gp					is count = 22 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(22-rt_raw)) = gp;}
reglist_sv32_21: s5					is count = 22 - rt_raw & rt_raw & s5; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(22-rt_raw)) = s5;}
reglist_sv32_21: s5,reglist_sv32_22	is rt_raw ... & reglist_sv32_22 & s5				{*:$(REGSIZE) (sp - $(REGSIZE)*(22-rt_raw)) = s5;}
reglist_sv32_20: gp					is count = 21 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(21-rt_raw)) = gp;}
reglist_sv32_20: s4					is count = 21 - rt_raw & rt_raw & s4; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(21-rt_raw)) = s4;}
reglist_sv32_20: s4,reglist_sv32_21	is rt_raw ... & reglist_sv32_21 & s4				{*:$(REGSIZE) (sp - $(REGSIZE)*(21-rt_raw)) = s4;}
reglist_sv32_19: gp					is count = 20 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(20-rt_raw)) = gp;}
reglist_sv32_19: s3					is count = 20 - rt_raw & rt_raw & s3; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(20-rt_raw)) = s3;}
reglist_sv32_19: s3,reglist_sv32_20	is rt_raw ... & reglist_sv32_20 & s3				{*:$(REGSIZE) (sp - $(REGSIZE)*(20-rt_raw)) = s3;}
reglist_sv32_18: gp					is count = 19 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(19-rt_raw)) = gp;}
reglist_sv32_18: s2					is count = 19 - rt_raw & rt_raw & s2; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(19-rt_raw)) = s2;}
reglist_sv32_18: s2,reglist_sv32_19	is rt_raw ... & reglist_sv32_19 & s2				{*:$(REGSIZE) (sp - $(REGSIZE)*(19-rt_raw)) = s2;}
reglist_sv32_17: gp					is count = 18 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(18-rt_raw)) = gp;}
reglist_sv32_17: s1					is count = 18 - rt_raw & rt_raw & s1; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(18-rt_raw)) = s1;}
reglist_sv32_17: s1,reglist_sv32_18	is rt_raw ... & reglist_sv32_18 & s1				{*:$(REGSIZE) (sp - $(REGSIZE)*(18-rt_raw)) = s1;}
reglist_sv32_16: gp					is count = 17 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(17-rt_raw)) = gp;}
reglist_sv32_16: s0					is count = 17 - rt_raw & rt_raw & s0; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(17-rt_raw)) = s0;}
reglist_sv32_16: s0,reglist_sv32_17	is rt_raw ... & reglist_sv32_17 & s0				{*:$(REGSIZE) (sp - $(REGSIZE)*(17-rt_raw)) = s0;}
reglist_sv32_15: gp					is count = 16 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(16-rt_raw)) = gp;}
reglist_sv32_15: t3					is count = 16 - rt_raw & rt_raw & t3; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(16-rt_raw)) = t3;}
reglist_sv32_15: t3,reglist_sv32_16	is rt_raw ... & reglist_sv32_16 & t3				{*:$(REGSIZE) (sp - $(REGSIZE)*(16-rt_raw)) = t3;}
reglist_sv32_14: gp					is count = 15 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(15-rt_raw)) = gp;}
reglist_sv32_14: t2					is count = 15 - rt_raw & rt_raw & t2; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(15-rt_raw)) = t2;}
reglist_sv32_14: t2,reglist_sv32_15	is rt_raw ... & reglist_sv32_15 & t2				{*:$(REGSIZE) (sp - $(REGSIZE)*(15-rt_raw)) = t2;}
reglist_sv32_13: gp					is count = 14 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(14-rt_raw)) = gp;}
reglist_sv32_13: t1					is count = 14 - rt_raw & rt_raw & t1; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(14-rt_raw)) = t1;}
reglist_sv32_13: t1,reglist_sv32_14	is rt_raw ... & reglist_sv32_14 & t1				{*:$(REGSIZE) (sp - $(REGSIZE)*(14-rt_raw)) = t1;}
reglist_sv32_12: gp					is count = 13 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(13-rt_raw)) = gp;}
reglist_sv32_12: t0					is count = 13 - rt_raw & rt_raw & t0; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(13-rt_raw)) = t0;}
reglist_sv32_12: t0,reglist_sv32_13	is rt_raw ... & reglist_sv32_13 & t0				{*:$(REGSIZE) (sp - $(REGSIZE)*(13-rt_raw)) = t0;}
reglist_sv32_11: gp					is count = 12 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(12-rt_raw)) = gp;}
reglist_sv32_11: a7					is count = 12 - rt_raw & rt_raw & a7; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(12-rt_raw)) = a7;}
reglist_sv32_11: a7,reglist_sv32_12	is rt_raw ... & reglist_sv32_12 & a7				{*:$(REGSIZE) (sp - $(REGSIZE)*(12-rt_raw)) = a7;}
reglist_sv32_10: gp					is count = 11 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(11-rt_raw)) = gp;}
reglist_sv32_10: a6					is count = 11 - rt_raw & rt_raw & a6; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(11-rt_raw)) = a6;}
reglist_sv32_10: a6,reglist_sv32_11	is rt_raw ... & reglist_sv32_11 & a6				{*:$(REGSIZE) (sp - $(REGSIZE)*(11-rt_raw)) = a6;}
reglist_sv32_09: gp					is count = 10 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(10-rt_raw)) = gp;}
reglist_sv32_09: a5					is count = 10 - rt_raw & rt_raw & a5; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(10-rt_raw)) = a5;}
reglist_sv32_09: a5,reglist_sv32_10	is rt_raw ... & reglist_sv32_10 & a5				{*:$(REGSIZE) (sp - $(REGSIZE)*(10-rt_raw)) = a5;}
reglist_sv32_08: gp					is count = 9 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(9-rt_raw)) = gp;}
reglist_sv32_08: a4					is count = 9 - rt_raw & rt_raw & a4; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(9-rt_raw)) = a4;}
reglist_sv32_08: a4,reglist_sv32_09	is rt_raw ... & reglist_sv32_09 & a4				{*:$(REGSIZE) (sp - $(REGSIZE)*(9-rt_raw)) = a4;}
reglist_sv32_07: gp					is count = 8 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(8-rt_raw)) = gp;}
reglist_sv32_07: a3					is count = 8 - rt_raw & rt_raw & a3; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(8-rt_raw)) = a3;}
reglist_sv32_07: a3,reglist_sv32_08	is rt_raw ... & reglist_sv32_08 & a3				{*:$(REGSIZE) (sp - $(REGSIZE)*(8-rt_raw)) = a3;}
reglist_sv32_06: gp					is count = 7 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(7-rt_raw)) = gp;}
reglist_sv32_06: a2					is count = 7 - rt_raw & rt_raw & a2; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(7-rt_raw)) = a2;}
reglist_sv32_06: a2,reglist_sv32_07	is rt_raw ... & reglist_sv32_07 & a2				{*:$(REGSIZE) (sp - $(REGSIZE)*(7-rt_raw)) = a2;}
reglist_sv32_05: gp					is count = 6 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(6-rt_raw)) = gp;}
reglist_sv32_05: a1					is count = 6 - rt_raw & rt_raw & a1; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(6-rt_raw)) = a1;}
reglist_sv32_05: a1,reglist_sv32_06	is rt_raw ... & reglist_sv32_06 & a1				{*:$(REGSIZE) (sp - $(REGSIZE)*(6-rt_raw)) = a1;}
reglist_sv32_04: gp					is count = 5 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(5-rt_raw)) = gp;}
reglist_sv32_04: a0					is count = 5 - rt_raw & rt_raw & a0; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(5-rt_raw)) = a0;}
reglist_sv32_04: a0,reglist_sv32_05	is rt_raw ... & reglist_sv32_05 & a0				{*:$(REGSIZE) (sp - $(REGSIZE)*(5-rt_raw)) = a0;}
reglist_sv32_03: gp					is count = 4 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(4-rt_raw)) = gp;}
reglist_sv32_03: t5					is count = 4 - rt_raw & rt_raw & t5; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(4-rt_raw)) = t5;}
reglist_sv32_03: t5,reglist_sv32_04	is rt_raw ... & reglist_sv32_04 & t5				{*:$(REGSIZE) (sp - $(REGSIZE)*(4-rt_raw)) = t5;}
reglist_sv32_02: gp					is count = 3 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(3-rt_raw)) = gp;}
reglist_sv32_02: t4					is count = 3 - rt_raw & rt_raw & t4; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(3-rt_raw)) = t4;}
reglist_sv32_02: t4,reglist_sv32_03	is rt_raw ... & reglist_sv32_03 & t4				{*:$(REGSIZE) (sp - $(REGSIZE)*(3-rt_raw)) = t4;}
reglist_sv32_01: gp					is count = 2 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(2-rt_raw)) = gp;}
reglist_sv32_01: at					is count = 2 - rt_raw & rt_raw & at; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(2-rt_raw)) = at;}
reglist_sv32_01: at,reglist_sv32_02	is rt_raw ... & reglist_sv32_02 & at				{*:$(REGSIZE) (sp - $(REGSIZE)*(2-rt_raw)) = at;}
reglist_sv32_00: gp					is count = 1 - rt_raw & rt_raw & gp; gp_end = 1	{*:$(REGSIZE) (sp - $(REGSIZE)*(1-rt_raw)) = gp;}
reglist_sv32_00: zero					is count = 1 - rt_raw & rt_raw & zero; gp_end = 0	{*:$(REGSIZE) (sp - $(REGSIZE)*(1-rt_raw)) = zero;}
reglist_sv32_00: zero,reglist_sv32_01	is rt_raw ... & reglist_sv32_01 & zero				{*:$(REGSIZE) (sp - $(REGSIZE)*(1-rt_raw)) = zero;}
reglist_sv32: 			is count = 0 {}
reglist_sv32: ,reglist_sv32_31	is rt_raw = 31 ... & reglist_sv32_31 {}
reglist_sv32: ,reglist_sv32_30	is rt_raw = 30 ... & reglist_sv32_30 {}
reglist_sv32: ,reglist_sv32_29	is rt_raw = 29 ... & reglist_sv32_29 {}
reglist_sv32: ,reglist_sv32_28	is rt_raw = 28 ... & reglist_sv32_28 {}
reglist_sv32: ,reglist_sv32_27	is rt_raw = 27 ... & reglist_sv32_27 {}
reglist_sv32: ,reglist_sv32_26	is rt_raw = 26 ... & reglist_sv32_26 {}
reglist_sv32: ,reglist_sv32_25	is rt_raw = 25 ... & reglist_sv32_25 {}
reglist_sv32: ,reglist_sv32_24	is rt_raw = 24 ... & reglist_sv32_24 {}
reglist_sv32: ,reglist_sv32_23	is rt_raw = 23 ... & reglist_sv32_23 {}
reglist_sv32: ,reglist_sv32_22	is rt_raw = 22 ... & reglist_sv32_22 {}
reglist_sv32: ,reglist_sv32_21	is rt_raw = 21 ... & reglist_sv32_21 {}
reglist_sv32: ,reglist_sv32_20	is rt_raw = 20 ... & reglist_sv32_20 {}
reglist_sv32: ,reglist_sv32_19	is rt_raw = 19 ... & reglist_sv32_19 {}
reglist_sv32: ,reglist_sv32_18	is rt_raw = 18 ... & reglist_sv32_18 {}
reglist_sv32: ,reglist_sv32_17	is rt_raw = 17 ... & reglist_sv32_17 {}
reglist_sv32: ,reglist_sv32_16	is rt_raw = 16 ... & reglist_sv32_16 {}
reglist_sv32: ,reglist_sv32_15	is rt_raw = 15 ... & reglist_sv32_15 {}
reglist_sv32: ,reglist_sv32_14	is rt_raw = 14 ... & reglist_sv32_14 {}
reglist_sv32: ,reglist_sv32_13	is rt_raw = 13 ... & reglist_sv32_13 {}
reglist_sv32: ,reglist_sv32_12	is rt_raw = 12 ... & reglist_sv32_12 {}
reglist_sv32: ,reglist_sv32_11	is rt_raw = 11 ... & reglist_sv32_11 {}
reglist_sv32: ,reglist_sv32_10	is rt_raw = 10 ... & reglist_sv32_10 {}
reglist_sv32: ,reglist_sv32_09	is rt_raw = 9 ... & reglist_sv32_09 {}
reglist_sv32: ,reglist_sv32_08	is rt_raw = 8 ... & reglist_sv32_08 {}
reglist_sv32: ,reglist_sv32_07	is rt_raw = 7 ... & reglist_sv32_07 {}
reglist_sv32: ,reglist_sv32_06	is rt_raw = 6 ... & reglist_sv32_06 {}
reglist_sv32: ,reglist_sv32_05	is rt_raw = 5 ... & reglist_sv32_05 {}
reglist_sv32: ,reglist_sv32_04	is rt_raw = 4 ... & reglist_sv32_04 {}
reglist_sv32: ,reglist_sv32_03	is rt_raw = 3 ... & reglist_sv32_03 {}
reglist_sv32: ,reglist_sv32_02	is rt_raw = 2 ... & reglist_sv32_02 {}
reglist_sv32: ,reglist_sv32_01	is rt_raw = 1 ... & reglist_sv32_01 {}
reglist_sv32: ,reglist_sv32_00	is rt_raw = 0 ... & reglist_sv32_00 {}

:SAVE lo_uimm12_sl3^reglist_sv32 is
	(hi_pool10_6 = 0b100000 & hi_pool4_1 = 0;
	lo_pool12_4 = 0b0011 & lo_uimm12_sl3 & gp_end & lo_pool0_2 = 0b00)
	& reglist_sv32
	{
		build reglist_sv32;
		# TODO effective_address
		sp = sp - lo_uimm12_sl3;
	}


# SB
## SB rt, offset(rs)
:SB rt, lo_uimm0_12(rs) is hi_pool10_6 = 0b100001 & rt & rs; lo_pool12_4 = 0b0001 & lo_uimm0_12 {
	#TODO: save only a byte? (specify 8 bits?)
	*(rs + lo_uimm0_12) = rt; # TODO: currently updating this to be correct, this is not correct atm
}

# SB
## SB[16] rt, offset(rs)
## TODO: replace with rtz3
## TODO: make uim
:SB rt3, hi_pool0_2(rs3) is hi_pool10_6 = 0b100111 & rt3 & rs3 & hi_pool2_2 = 0b01 & hi_pool0_2 {
	*(rs3 + hi_pool0_2) = rt3; # TODO: currently updating this to be correct, this is not correct atm
}

# SB
## SB[GP] rt, offset(rs)
##TODO:  SB[GP]/[s9[
:SB rt, lo_pool0_16(gp) is hi_pool10_6 = 0b010001 & rt & hi_pool2_3 = 0b001 & hi_pool0_2; lo_pool0_16 & gp {
	#TODO: save only a byte? (specify 8 bits?)
	#*(rs + lo_uimm0_12) = rt; # TODO: currently updating this to be correct, this is not correct atm
}

# SB
## SB[S9] rt, offset(rs)
:SB rt, lo_pool0_8(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b0001 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b00 & lo_pool0_8 {
	rt = *(rs + lo_pool0_8); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
}

# SBE
## SBE rd, rs, shift
:SBE rt, lo_pool0_8(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b0001 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10 & lo_pool0_8 {
	rt = *(rs + lo_pool0_8); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
}
# SBX
## SBX rd, rs, shift
:SBX rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool7_4 = 0b0001 & lo_pool6_1 = 0b0 & lo_pool3_3 = 0b000 & lo_pool0_3 = 0b111 {

}

# SC ()
## SC rd, rs, shift
:SC rt, lo_pool2_6(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b1011 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b01 & lo_pool2_6 & lo_pool0_2 = 0b00 {
	#*(rs3 + hi_pool0_2) = rt3; # TODO: currently updating this to be correct, this is not correct atm
}

# SCE ()
## SCE rd, rs, shift
:SCE rt, lo_pool2_6(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b1011 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10 & lo_pool2_6 & lo_pool0_2 = 0b00 {
	#*(rs3 + hi_pool0_2) = rt3; # TODO: currently updating this to be correct, this is not correct atm
}

# SCWP ()
## SCWP rd, rs, shift
:SCWP rt, lo_pool3_5(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b1011 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b01 & lo_pool3_5 & lo_pool0_2 = 0b01 {
	#*(rs3 + hi_pool0_2) = rt3; # TODO: currently updating this to be correct, this is not correct atm
}

# SCWPE ()
## SCWPE rd, rs, shift
:SCWPE rt, lo_pool3_5(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b1011 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10 & lo_pool3_5 & lo_pool0_2 = 0b01 {
	#*(rs3 + hi_pool0_2) = rt3; # TODO: currently updating this to be correct, this is not correct atm
}

# SDBBP
## SDBBP
:SDBBP is hi_pool10_6 = 0b000000 & hi_pool5_5 = 0b00000 & hi_pool3_2 = 0b11 & hi_pool0_3; lo_pool0_16 {
	# TODO: construct the code
	#rt = rs >> lo_pool0_5;
}

# SDBBP
## SDBBP[16]
:SDBBP is hi_pool10_6 = 0b001000 & hi_pool5_5 = 0b00000 & hi_pool3_2 = 0b11 & hi_pool0_2 {
	# TODO: construct the code
}


# SEB rt, rs
:SEB rt, rs is
	hi_pool10_6 = 0b001000 & rt & rs;
	lo_pool3_7 = 0b0000001 & lo_pool0_3 = 0b000
	{
		rt = sext(rs:1);
	}


# SEH rt, rs
:SEH rt, rs is
	hi_pool10_6 = 0b001000 & rt & rs;
	lo_pool3_7 = 0b0001001 & lo_pool0_3 = 0b000
	{
		rt = sext(rs:2);
	}


# SEQI rt, rs, u
:SEQI rt, rs, lo_uimm0_12 is
	hi_pool10_6 = 0b100000 & rt & rs;
	lo_pool12_4 = 0b0110 & lo_uimm0_12
	{
		# TODO verify == output is 0 or 1
		rt = zext(rs == lo_uimm0_12);
	}


# SH rt, offset(rs)
## SH[U12]
:SH rt, lo_rs_uoffset12 is
	(hi_pool10_6 = 0b100001 & rt;
	lo_pool12_4 = 0b0101)
	& lo_rs_uoffset12
	{
		*:2 lo_rs_uoffset12 = rt:2;
	}

## SH[16]
:SH rtz3, hi_rs3_uoffset3 is
	hi_pool10_6 = 0b011111 & rtz3 & hi_rs3_uoffset3 & hi_pool3_1 = 0b0 & hi_pool0_1 = 0b1
	{
		*:2 hi_rs3_uoffset3 = rtz3:2;
	}

## SH[GP]
:SH rt, hilo_gp_uoffset18_sl1 is
	(hi_pool10_6 = 0b010001 & rt & hi_pool2_3 = 0b101;
	lo_pool0_1 = 0b0)
	& hilo_gp_uoffset18_sl1
	{
		*:2 hilo_gp_uoffset18_sl1 = rt:2;
	}

## SH[S9]
:SH rt, lo_rs_soffset9 is
	(hi_pool10_6 = 0b101001 & rt;
	lo_pool11_4 = 0b0101 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b00)
	& lo_rs_soffset9
	{
		*:2 lo_rs_soffset9 = rt:2;
	}


# SIGRIE code
# TODO: Signal Reserved Instruction Exception
:SIGRIE code is hi_pool10_6 = 0b000000 & rt = 0 & hi_pool3_2 = 0b00 & hi_uimm0_3; uimm16
	[code = (hi_uimm0_3 << 16) | uimm16;] unimpl


# SLL
## SLL rd, rs, shift
:SLL rt, rs, lo_pool0_5 is hi_pool10_6 = 0b100000 & rt & rs; lo_pool12_4 = 0b1100 & lo_pool5_4 = 0b0000 & lo_pool0_5 {
	rt = rs << lo_pool0_5;
}

# SLL
## SLL[16] rt3, rs3, shift
:SLL rt3, rs3, hi_pool0_3 is hi_pool10_6 = 0b001100 & rt3 & rs3 & hi_pool3_1 = 0 & hi_pool0_3 {
	rt3 = rs3 << hi_pool0_3;
}




# SLLV
## SLLV rd, rs, shift
:SLLV rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0000010 & lo_pool0_3 = 0b000 {
	rd = rs << (rt & 0x1f);
}

# SLT
## SLT rd, rs, rt
:SLT rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b1101010 & lo_pool0_3 = 0b000 {
	#TODO: finish this out
}




# SLTI
## SLTI rd, rs, rt
:SLTI rt, rs, lo_pool0_12 is hi_pool10_6 = 0b100000  & rt & rs; lo_pool12_4 = 0b0100 & lo_pool0_12 {
	#TODO: finish this out
}

# SLTIU
## SLTIU rd, rs, rt
:SLTIU rt, rs, lo_pool0_12 is hi_pool10_6 = 0b100000  & rt & rs; lo_pool12_4 = 0b0101 & lo_pool0_12 {
	#TODO: finish this out
}

# SLTU
## SLTU rd, rs, rt
:SLTU rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b1110010 & lo_pool0_3 = 0b000 {
	sum = rs + rt;
	#TODO: finish this out
}

# SOV
## SOV rd, rs, rt
:SOV rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b1111010 & lo_pool0_3 = 0b000 {
	sum = rs + rt;
	#TODO: finish this out
}

# SRA
## SRA rd, rs, shift
:SRA rt, rs, lo_pool0_5 is hi_pool10_6 = 0b100000 & rt & rs; lo_pool12_4 = 0b1100 & lo_pool5_4 = 0b0100 & lo_pool0_5 {
	rt = rs >> lo_pool0_5;
}

# SRAV
## SRAV rd, rs, rt
:SRAV rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0010010 & lo_pool0_3 = 0b000 {
	rd = rs >> (rt & 0x1f);
}

# SRL
## SRL rd, rs, shift
:SRL rt, rs, lo_pool0_5 is hi_pool10_6 = 0b100000 & rt & rs; lo_pool12_4 = 0b1100 & lo_pool5_4 = 0b0010 & lo_pool0_5 {
    # TODO: incorporate signed extend
	rt = rs >> lo_pool0_5;
}

# SRL
## SRL[16] rt3, rs3, shift
:SRL rt3, rs3, hi_pool0_3 is hi_pool10_6 = 0b001100 & rt3 & rs3 & hi_pool3_1 = 1 & hi_pool0_3 {
	# TODO: incorporate signe extend
	rt3 = rs3 >> hi_pool0_3;
}

# SRLV
## SRLV rd, rs, rt
:SRLV rd, rs, rt is hi_pool10_6 = 0b100000 & rt & rs; rd & lo_pool3_7 = 0b0001010 & lo_pool0_3 = 0b000 {
    # TODO: incorporate signed extend
	rd = rs >> (rt & 0x1f);
}

# SUB rd, rs, rt
:SUB rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0110010 & lo_pool0_3 = 0b000 {
	rd = rs - rt;
	# TODO: trap on overflow
	# TODO: sign extend?
}

# SUBU rd, rs, rt
:SUBU rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0111010 & lo_pool0_3 = 0b000 {
	rd = rs - rt;
	# TODO: trap on overflow
	# TODO: sign extend?
}

# SUBU rt, rs, imm
## SUBU[16]
# TODO: rt != 0 constraint doesn't work here (covered by SIGRIE?)
:SUBU rd3, rs3, rt3 is hi_pool10_6 = 0b101100  & rt3 & rs3 & rd3 & hi_pool0_1 = 0b1 {
	rd3 = rs3 + rt3;
}

# SW rt, offset(rs)
## SW[U12]
:SW rt, lo_rs_uoffset12 is
	(hi_pool10_6 = 0b100001 & rt;
	lo_pool12_4 = 0b1001)
	& lo_rs_uoffset12
	{
		*:4 lo_rs_uoffset12 = rt:4;
	}

## SW[16]
:SW rtz3, hi_rs3_uoffset6 is
	hi_pool10_6 = 0b100101 & rtz3 & hi_rs3_uoffset6
	{
		*:4 hi_rs3_uoffset6 = rtz3:4;
	}

## SW[4X4]
:SW rtz4, hi_rs4_uoffset4 is
	hi_pool10_6 = 0b111101 & rtz4 & hi_rs4_uoffset4
	{
		*:4 hi_rs4_uoffset4 = rtz4:4;
	}

## SW[GP]
:SW rt, hilo_gp_uoffset21 is
	(hi_pool10_6 = 0b010000 & rt;
	lo_pool0_2 = 0b11)
	& hilo_gp_uoffset21
	{
		*:4 hilo_gp_uoffset21 = rt:4;
	}

## SW[GP16]
:SW rtz3, hi_gp_uoffset9 is
	hi_pool10_6 = 0b110101 & rtz3 & hi_gp_uoffset9
	{
		*:4 hi_gp_uoffset9 = rtz3:4;
	}

## SW[S9]
:SW rt, lo_rs_soffset9 is
	(hi_pool10_6 = 0b101001 & rt;
	lo_pool11_4 = 0b1001 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b00)
	& lo_rs_soffset9
	{
		*:4 lo_rs_soffset9 = rt:4;
	}

## SW[SP]
:SW rt, hi_sp_uoffset7 is
	hi_pool10_6 = 0b101101 & rt & hi_sp_uoffset7
	{
		*:4 hi_sp_uoffset7 = rt:4;
	}


# SWE rt, offset(rs)
:SWE rt, lo_rs_soffset9 is
	(hi_pool10_6 = 0b101001 & rt;
	lo_pool11_4 = 0b1001 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10)
	& lo_rs_soffset9
	{
		# TODO EVA addressing mode
		*:4 lo_rs_soffset9 = rt:4;
	}


# SWM rt, offset(rs), count
:SWM rt, lo_rs_soffset9, count3 is
	(hi_pool10_6 = 0b101001 & rt;
	count3 & lo_pool11_1 = 0b1 & lo_pool10_1 = 0b1 & lo_pool8_2 = 0b00)
	& lo_rs_soffset9
	unimpl


# SWPC rt, address
## SWPC[48]
:SWPC rt, pc_rel_saddr32 is
	hi_pool10_6 = 0b011000 & rt & hi_pool0_5 = 0b01111;
	pc_rel_saddr32
	{
		*:4 pc_rel_saddr32 = rt:4;
	}


# SWX rd, rs(rt)
:SWX rd, rt_offset_rs is
	hi_pool10_6 = 0b001000 & rt_offset_rs;
	rd & lo_pool7_4 = 0b1001 & lo_pool6_1 = 0b0 & lo_pool3_3 = 0b000 & lo_pool0_3 = 0b111
	{
		# docs have a possible typo in purpose saying data comes from rt,
		# but the pseudo-code shows it comes from rd
		*:4 rt_offset_rs = rd:4;
	}


# SWXS rd, rs(rt)
:SWXS rd, rt_offset_4rs is
	hi_pool10_6 = 0b001000 & rt_offset_4rs;
	rd & lo_pool7_4 = 0b1001 & lo_pool6_1 = 0b1 & lo_pool3_3 = 0b000 & lo_pool0_3 = 0b111
	{
		# docs have a possible typo in purpose saying data comes from rt,
		# but the pseudo-code shows it comes from rd
		*:4 rt_offset_4rs = rd:4;
	}


# SYNC stype
define pcodeop sync;

## stype=0 implied
:SYNC is
	hi_pool10_6 = 0b100000 & hi_pool5_5 = 0b00000 & hi_uimm0_5 = 0;
	lo_pool12_4 = 0b1100 & lo_pool5_4 = 0b0000 & lo_pool0_5 = 0b00110
	{
		sync(0:1);
	}

:SYNC hi_uimm0_5 is
	hi_pool10_6 = 0b100000 & hi_pool5_5 = 0b00000 & hi_uimm0_5;
	lo_pool12_4 = 0b1100 & lo_pool5_4 = 0b0000 & lo_pool0_5 = 0b00110
	{
		sync(hi_uimm0_5:1);
	}


# SYNCI(E) offset(rs)
define pcodeop synci;
define pcodeop syncie;

## SYNCI[S9]
:SYNCI lo_rs_soffset9 is
	(hi_pool10_6 = 0b101001 & hi_pool5_5 = 0b11111;
	lo_pool11_4 = 0b0011 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b00)
	& lo_rs_soffset9
	{
		synci(lo_rs_soffset9:4);
	}

## SYNCI[U12]
:SYNCI lo_rs_uoffset12 is
	(hi_pool10_6 = 0b100001 & hi_pool5_5 = 0b11111;
	lo_pool12_4 = 0b0011)
	& lo_rs_uoffset12
	{
		synci(lo_rs_uoffset12:4);
	}

## SYNCIE, present when Config5.EVA=1, requires CP0 privilege.
:SYNCIE lo_rs_soffset9 is
	(hi_pool10_6 = 0b101001 & hi_pool5_5 = 0b11111;
	lo_pool11_4 = 0b0011 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10)
	& lo_rs_soffset9
	{
		syncie(lo_rs_soffset9:4);
	}


# SYSCALL code
define pcodeop syscall;

## SYSCALL[32]
:SYSCALL code is
	hi_pool10_6 = 0b000000 & rt = 0 & hi_pool3_2 = 0b01 & hi_pool2_1 = 0b0 & hi_uimm0_2;
	uimm16
	[
		code = (hi_uimm0_2 << 16) | uimm16;
	]
	{
		syscall(code:4);
	}

## SYSCALL[16]
:SYSCALL hi_uimm0_2 is
	hi_pool10_6 = 0b000100 & rt = 0 & hi_pool3_2 = 0b01 & hi_pool2_1 = 0b0 & hi_uimm0_2
	{
		syscall(hi_uimm0_2:4);
	}


# TEQ rs, rt, code
define pcodeop trap;
:TEQ rs, rt, lo_uimm11_5 is
	hi_pool10_6 = 0b001000 & rt & rs;
	lo_uimm11_5 & lo_pool10_1 = 0b0 & lo_pool3_7 = 0b0000000 & lo_pool0_3 = 0b000
	{
		trap(lo_uimm11_5:1);
	}


# TLBINV
:TLBINV is
	hi_pool10_6 = 0b001000;
	lo_pool14_2 = 0b00 & lo_pool9_5 = 0b00011 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	unimpl


# TLBINVF
:TLBINVF is
	hi_pool10_6 = 0b001000;
	lo_pool14_2 = 0b00 & lo_pool9_5 = 0b01011 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	unimpl


# TLBP
:TLBP is
	hi_pool10_6 = 0b001000;
	lo_pool14_2 = 0b00 & lo_pool9_5 = 0b00001 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	unimpl


# TLBR
:TLBR is
	hi_pool10_6 = 0b001000;
	lo_pool14_2 = 0b00 & lo_pool9_5 = 0b01001 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	unimpl


# TLBWI
:TLBWI is
	hi_pool10_6 = 0b001000;
	lo_pool14_2 = 0b00 & lo_pool9_5 = 0b10001 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	unimpl


# TLBWR
:TLBWR is
	hi_pool10_6 = 0b001000;
	lo_pool14_2 = 0b00 & lo_pool9_5 = 0b11001 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	unimpl


# TNE rs, rt, code
:TNE rs, rt, lo_uimm11_5 is
	hi_pool10_6 = 0b001000 & rt & rs;
	lo_uimm11_5 & lo_pool10_1 = 0b1 & lo_pool3_7 = 0b0000000 & lo_pool0_3 = 0b000
	{
		trap(lo_uimm11_5:1);
	}


# UALH rt, offset(rs)
:UALH rt, lo_rs_soffset9 is
	(hi_pool10_6 = 0b101001 & rt;
	lo_pool11_4 = 0b0100 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b01)
	& lo_rs_soffset9
	{
		rt = sext(*:2 lo_rs_soffset9);
	}


# UALW rt, offset(rs)
## alias for UALWM count=1
:UALW rt, lo_soffset9(rs) is
	hi_pool10_6 = 0b101001 & rt & rs;
	count3 = 1 & lo_pool11_1 = 0b0 & lo_pool10_1 = 0b1 & lo_pool8_2 = 0b01 & lo_soffset9
	unimpl


# UALWM rt, offset(rs), count
:UALWM rt, lo_soffset9(rs), count3 is
	hi_pool10_6 = 0b101001 & rt & rs;
	count3 & lo_pool11_1 = 0b0 & lo_pool10_1 = 0b1 & lo_pool8_2 = 0b01 & lo_soffset9
	unimpl


# UASH rt, offset(rs)
:UASH rt, lo_soffset9(rs) is
	hi_pool10_6 = 0b101001 & rt & rs;
	lo_pool11_4 = 0b0101 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b01 & lo_soffset9
	unimpl


# UASW rt, offset(rs)
## alias for UASWM count=1
:UASW rt, lo_soffset9(rs) is
	hi_pool10_6 = 0b101001 & rt & rs;
	count3 = 1 & lo_pool11_1 = 0b1 & lo_pool10_1 = 0b1 & lo_pool8_2 = 0b01 & lo_soffset9
	unimpl


# UASWM rt, offset(rs), count
:UASWM rt, lo_soffset9(rs), count3 is
	hi_pool10_6 = 0b101001 & rt & rs;
	count3 & lo_pool11_1 = 0b1 & lo_pool10_1 = 0b1 & lo_pool8_2 = 0b01 & lo_soffset9
	unimpl


# WAIT code
:WAIT is
	hi_pool10_6 = 0b001000 & hi_uimm0_10 = 0;
	lo_pool14_2 = 0b11 & lo_pool9_5 = 0b00001 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	unimpl

:WAIT hi_uimm0_10 is
	hi_pool10_6 = 0b001000 & hi_uimm0_10;
	lo_pool14_2 = 0b11 & lo_pool9_5 = 0b00001 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	unimpl


# WRPGPR rt, rs
# "Write Previous GPR. Write the value of register $rs from the current shadow register set (SRSCtl.CSS) to register $rt in the previous shadow register set (SRSCtl.PSS). If shadow register sets are not implemented, just copy the value from register $rs to register $rt."
# TODO "Requires CP0 privilege."
:WRPGPR rt, rs is
	hi_pool10_6 = 0b001000 & rt & rs;
	lo_pool14_2 = 0b11 & lo_pool9_5 = 0b11000 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	{
		# TODO shadow register stuff
		rt = rs;
	}


# XOR rd, rs, rt
## XOR[32]
:XOR rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b1100010 & lo_pool0_3 = 0b000 {
	rd = rs ^ rt;
}

## XOR[16]
:XOR rd3_from_rt3, rs3, rt3 is hi_pool10_6 = 0b010100 & rt3 & rd3_from_rt3 & rs3 & hi_pool2_2 = 0b01 & hi_pool1_1 = 0 & hi_pool0_1 = 0 {
	rd3_from_rt3 = rs3 ^ rt3;
}


# XORI rt, rs, u
:XORI rt, rs, lo_uimm0_12 is
	hi_pool10_6 = 0b100000 & rt & rs;
	lo_pool12_4 = 0b0001 & lo_uimm0_12
	{
		rt = rs ^ lo_uimm0_12;
	}
