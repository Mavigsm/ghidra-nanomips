# sleigh include file for Skeleton language instructions

define token instrhi(16)
	hi_pool10_6 = (10, 15)  # MAJOR / P32 / P16
	hi_pool9_1 = (9, 9)
	hi_pool8_1 = (8, 8)
	hi_pool6_1 = (6, 6)
	hi_pool4_1 = (4, 4)
	hi_pool3_2 = (3, 4)
	hi_pool3_1 = (3, 3)
	hi_pool2_3 = (2, 4)
	hi_pool2_2 = (2, 3)
	hi_pool2_1 = (2, 2)
	hi_pool1_1 = (1, 1)
	hi_pool0_5 = (0, 4)  # P48I, P.BR3A
	hi_pool0_4 = (0, 3)  # P16.BR u[4:1]
	hi_pool0_1 = (0, 0)
	
	hint = (5, 9)  # hi_pool5_5
	
	u4_1 = (0, 4)  # u[4:1] - naming convention conflict
	
	rt = (5, 9)
	rs_from_rt = (5, 9)  # :'(
	rs = (0, 4)
	
	rt3 = (7, 9)
	rs3 = (4, 6)
	
	eu_imm7 = (0, 6)
	hi_uimm0_2 = (0, 1)
	hi_uimm0_5 = (0, 4)
	hi_uimm0_6 = (0, 5)
	hi_uimm0_3 = (0, 2)
	
	hi_simm4_1 = (4, 4)
	hi_simm0_3 = (0, 2)
	;
	
define token instrlo(16)
	lo_pool14_2 = (14, 15)
	lo_pool12_4 = (12, 15)
	lo_pool11_4 = (11, 14)
	lo_pool11_1 = (11, 11)
	lo_pool10_3 = (10, 12)
	lo_pool10_1 = (10, 10)
	lo_pool9_7 = (9, 15)
	lo_pool9_5 = (9, 13)
	lo_pool8_3 = (8, 10)
	lo_pool7_4 = (7, 10)
	lo_pool6_4 = (6, 9)
	lo_pool6_3 = (6, 8)
	lo_pool6_1 = (6, 6)
	lo_pool5_4 = (5, 8)
	lo_pool5_1 = (5, 5)
	lo_pool3_7 = (3, 9)
	lo_pool3_3 = (3, 5)
	lo_pool3_2 = (3, 4)
	lo_pool2_2 = (2, 3)
	lo_pool1_1 = (1, 1)
	lo_pool0_3 = (0, 2)
	lo_pool0_2 = (0, 1)
	lo_pool0_1 = (0, 0)
	
	shift = (0, 4)
	
	rd = (11, 15)
	
	lo_uimm0_12 = (0, 11)
	;
	
define token data16(16)
	hi_imm16 = (0, 15) signed
	lo_imm16 = (0, 15)
	uimm16 = (0, 15)
	uimm2_14 = (2, 15)
	uimm0_2 = (0, 1)
	;

attach variables [ rt rs rs_from_rt rd ] [
	zero
	at
	t4 t5
	a0 a1 a2 a3
	a4 a5 a6 a7
	t0 t1 t2 t3
	s0 s1 s2 s3
	s4 s5 s6 s7
	t8 t9
	k0 k1
	gp sp fp ra
];

# gpr3: [16, 17, 18, 19, 4, 5, 6, 7]
attach variables [ rt3 rs3 ] [
	s0 s1 s2 s3
	a0 a1 a2 a3
];

################################################################
# Macros
################################################################

# macro setResultFlags(result) {
# 	$(Z_flag) = (result == 0);
# 	$(S_flag) = (result s< 0);
# }
# 
# macro setAddCarryFlags(op1,op2) {
# 	$(C_flag) = (carry(op1,zext($(C_flag))) || carry(op2,op1 + zext($(C_flag))));
# }
# 
# macro setAddFlags(op1,op2) {
# 	$(C_flag) = carry(op1,op2);
# }
# 
# macro setSubtractCarryFlags(op1,op2) {
# 	notC = ~$(C_flag);
# 	$(C_flag) = ((op1 < sext(notC)) || (op2 < (op1 - sext(notC))));
# }
# 
# macro setSubtractFlags(op1,op2) {
# 	$(C_flag) = (op1 < op2);
# }
# 
# macro push16(val16) {
# 	SP = SP - 2;
# 	*:2 SP = val16; 
# }
# 
# macro pop16(ret16) {
# 	ret16 = *:2 SP;
# 	SP = SP + 2; 
# }
# 
# macro push8(val8) {
# 	SP = SP - 1;
# 	ptr:2 = SP;
# 	*:1 ptr = val8; 
# }
# 
# macro pop8(ret8) {
#     ptr:2 = SP;
# 	ret8 = *:1 ptr;
# 	SP = SP + 1; 
# }
# 
# ################################################################
# ixMem8: (IX+simm8)  is IX & simm8								{ ptr:2 = IX + simm8; export *:1 ptr; }
# ixMem8: (IX-val)    is IX & simm8 & sign8=1	[ val = -simm8; ]	{ ptr:2 = IX + simm8; export *:1 ptr; }
# 
# iyMem8: (IY+simm8)  is IY & simm8								{ ptr:2 = IY + simm8; export *:1 ptr; }
# iyMem8: (IY-val)    is IY & simm8 & sign8=1	[ val = -simm8; ]	{ ptr:2 = IY + simm8; export *:1 ptr; }
# 
# Addr16: imm16		is imm16									{ export *:1 imm16; }
# 
# Mem16: (imm16)		is imm16									{ export *:2 imm16; }
# 
# RelAddr8: loc		is simm8  [ loc = inst_next + simm8; ]		{ export *:1 loc; }
# 
# cc: "NZ"            is bits3_3=0x0                              { c:1 = ($(Z_flag) == 0); export c; }
# cc: "Z"             is bits3_3=0x1                              { c:1 = $(Z_flag); export c; }
# cc: "NC"            is bits3_3=0x2                              { c:1 = ($(C_flag) == 0); export c; }
# cc: "C"             is bits3_3=0x3                              { c:1 = $(C_flag); export c; }
# cc: "PO"            is bits3_3=0x4                              { c:1 = ($(PV_flag) == 0); export c; }
# cc: "PE"            is bits3_3=0x5                              { c:1 = $(PV_flag); export c; }
# cc: "P"             is bits3_3=0x6                              { c:1 = ($(S_flag) == 0); export c; }
# cc: "M"             is bits3_3=0x7                              { c:1 = $(S_flag); export c; }
# 
# cc2: "NZ"            is bits3_3=0x4                              { c:1 = ($(Z_flag) == 0); export c; }
# cc2: "Z"             is bits3_3=0x5                              { c:1 = $(Z_flag); export c; }
# cc2: "NC"            is bits3_3=0x6                              { c:1 = ($(C_flag) == 0); export c; }
# cc2: "C"             is bits3_3=0x7                              { c:1 = $(C_flag); export c; }
# ################################################################

# ADD rd, rs, rt
:ADD rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0100010 & lo_pool0_3 = 0b000 {
	rd = rs + rt;
	# TODO: trap on overflow
	# TODO: sign extend?
}

# ADDIU rt, rs, imm
## ADDIU[32]
# TODO: rt != 0 constraint doesn't work here
:ADDIU rt, rs, uimm16 is hi_pool10_6 = 0b000000 & rt & rs; uimm16 {
	rt = rs + uimm16;
}

## ADDIU[48]
:ADDIU rt, rs_from_rt, s32 is hi_pool10_6 = 0b011000 & rt & rs_from_rt & hi_pool0_5 = 0b00001; lo_imm16; hi_imm16
	[s32 = (hi_imm16 << 16) | lo_imm16;] {
	# TODO signedness
	rt = rs_from_rt + s32;
}

## ADDIU[GP48]
# TODO: not available in P64 mode
:ADDIU rt, rs, s32 is hi_pool10_6 = 0b011000 & rt & hi_pool0_5 = 0b00010; lo_imm16; hi_imm16
	[rs = gp; s32 = (hi_imm16 << 16) | lo_imm16;] {
	# TODO signedness
	# rs = $r28 = gp
	rt = rs + s32;
}

## ADDIU[GP.B]
# TODO: not available in P64 mode
:ADDIU rt, rs, u18 is hi_pool10_6 = 0b010001 & rt & hi_pool2_3 = 0b011 & hi_uimm0_2; uimm16
	[rs = gp; u18 = (hi_uimm0_2 << 16) | uimm16;] {
	rt = rs + u18;
}

## ADDIU[GP.W]
# TODO: not available in P64 mode
:ADDIU rt, rs, u21 is hi_pool10_6 = 0b010000 & rt & hi_uimm0_5; uimm2_14 & uimm0_2 = 0b00
	[rs = gp; u21 = (hi_uimm0_5 << 18) | (uimm2_14 << 2);] {
	rt = rs + u21;
}

## ADDIU[R1.SP]
# TODO: not available in P64 mode
:ADDIU rt3, rs, u8 is hi_pool10_6 = 0b011100 & rt3 & hi_pool6_1 = 0b1 & hi_uimm0_6
	[rs = sp; u8 = hi_uimm0_6 << 2;] {
		rt3 = rs + u8;
}

## ADDIU[R2]
:ADDIU rt3, rs3, u5 is hi_pool10_6 = 0b100100 & rt3 & rs3 & hi_pool3_1 = 0b0 & hi_uimm0_3
	[u5 = hi_uimm0_3 << 2;] {
		rt3 = rs3 + u5;
}

## ADDIU[RS5]
### ADDIU[RS5] with rt=0 is used to provide a 16 bit NOP instruction.
:NOP is hi_pool10_6 = 0b100100 & rt = 0 & hi_simm4_1 & hi_pool3_1 = 0b1 & hi_simm0_3 {}

# TODO: rt != 0 constraint doesn't work here (OK with NOP rule?)
:ADDIU rt, rs_from_rt, s4 is hi_pool10_6 = 0b100100 & rt & rs_from_rt & hi_simm4_1 & hi_pool3_1 = 0b1 & hi_simm0_3
	[s4 = (hi_simm4_1 << 3) | hi_simm0_3;] {
	rt = rs_from_rt + s4;
	# TODO s4 is signed
}

## ADDIU[NEG]
:ADDIU rt, rs, lo_uimm0_12 is hi_pool10_6 = 0b100000 & rt & rs; lo_pool12_4 = 0b1000 & lo_uimm0_12 {
	rt = rs - lo_uimm0_12;
}

# LI
## LI[16]
:LI rt3, s is hi_pool10_6 = 0b110100 & rt3 & eu_imm7 = 127 [s = -1;] {
	rt3 = s;
}

:LI rt3, eu_imm7 is hi_pool10_6 = 0b110100 & rt3 & eu_imm7 {
	rt3 = eu_imm7;
} 

## LI[48]
:LI rt, s32 is hi_pool10_6 = 0b011000 & rt & hi_pool0_5 = 0b00000; lo_imm16; hi_imm16 [s32 = (hi_imm16 << 16) | lo_imm16;] {
	rt = s32;
	# TODO: is signedness maintained correctly?
}


# JRC
:JRC rt is hi_pool10_6 = 0b110110 & rt & hi_pool4_1 = 0 & hi_pool0_4 = 0b0000 {
	pc = rt;
}

# AND
## AND rd, rs, rt
:AND rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b1001010 & lo_pool0_3 = 0b000 {
	rd = rs & rt;
}

## AND[16]
:AND rt3, rs3 is hi_pool10_6 = 0b010100 & rt3 & rs3 & hi_pool2_2 = 0b10 & hi_pool1_1 = 0 & hi_pool0_1 = 0 {
	rt3 = rs3 & rt3;
}

# OR
## OR rd, rs, rt
:OR rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b1010010 & lo_pool0_3 = 0b000 {
	rd = rs | rt;
}

## OR[16]
:OR rt3, rs3 is hi_pool10_6 = 0b010100 & rt3 & rs3 & hi_pool2_2 = 0b11 & hi_pool1_1 = 0 & hi_pool0_1 = 0 {
	rt3 = rs3 ^ rt3;
}


# SIGRIE code
# TODO: Signal Reserved Instruction Exception
:SIGRIE code is hi_pool10_6 = 0b000000 & rt = 0 & hi_pool3_2 = 0b00 & hi_uimm0_3; uimm16
	[code = (hi_uimm0_3 << 16) | uimm16;] unimpl


# XOR
## XOR rd, rs, rt
:XOR rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b1100010 & lo_pool0_3 = 0b000 {
	rd = rs ^ rt;
}

## XOR[16]
:XOR rt3, rs3 is hi_pool10_6 = 0b010100 & rt3 & rs3 & hi_pool2_2 = 0b01 & hi_pool1_1 = 0 & hi_pool0_1 = 0 {
	rt3 = rs3 ^ rt3;
}

# MOVE
## MOVE rt, rs
:MOVE rt, rs is hi_pool10_6 = 0b000100 & rt & rs {
	rt = rs;
}


