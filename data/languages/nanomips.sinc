# sleigh include file for Skeleton language instructions

define token instrhi(16)
	hi_pool10_6 = (10, 15)  # MAJOR / P32 / P16
	hi_pool9_1 = (9, 9)
	hi_pool8_1 = (8, 8)
	hi_pool6_1 = (6, 6)
	hi_pool4_1 = (4, 4)
	hi_pool3_2 = (3, 4)
	hi_pool3_1 = (3, 3)
	hi_pool2_3 = (2, 4)
	hi_pool2_2 = (2, 3)
	hi_pool2_1 = (2, 2)
	hi_pool1_1 = (1, 1)
	hi_pool0_5 = (0, 4)  # P48I, P.BR3A
	hi_pool0_4 = (0, 3)  # P16.BR u[4:1]
	hi_pool0_3 = (0, 2)
	hi_pool0_1 = (0, 0)
	
	hint = (5, 9)  # hi_pool5_5
	
	u4_1 = (0, 4)  # u[4:1] - naming convention conflict
	
	rt = (5, 9)
	rt_raw = (5, 9)  # :'(
	rs_from_rt = (5, 9)  # :'(
	rs = (0, 4)
	
	c0s = (0, 4) # for MFC0

	rt1 = (9, 9)

	rt3 = (7, 9)
	rt3_raw = (7, 9)
	rs3 = (4, 6)
	rs3_raw = (4, 6)
	rd3 = (1, 3)
	
	rt4x = (5, 9)
	rd4x_from_rt4x = (5, 9)
	rs4x = (0, 4)
	
	eu_imm7 = (0, 6)
	hi_uimm0_2 = (0, 1)
	hi_uimm0_5 = (0, 4)
	hi_uimm0_6 = (0, 5)
	hi_uimm0_4 = (0, 3)
	hi_uimm0_3 = (0, 2)
	hi_uimm0_1 = (0, 0)

	hi_simm4_1 = (4, 4)
	hi_simm1_6 = (1, 6)
	hi_simm1_9 = (1, 9)
	hi_simm0_9 = (0, 8)
	hi_simm0_5 = (0, 4)
	hi_simm0_3 = (0, 2)
	hi_simm0_1 = (0, 0)
	hi_signbit0_1 = (0, 0) signed

	u_imm5 = (0, 4)
	eu_imm4 = (0, 3)
	u_imm4_4 = (4, 7)
	u_imm4 = (0, 3)
	;
	
define token instrlo(16)
	lo_pool14_2 = (14, 15)
	lo_pool12_4 = (12, 15)
	lo_pool11_4 = (11, 14)
	lo_pool11_1 = (11, 11)
	lo_pool10_3 = (10, 12)
	lo_pool10_1 = (10, 10)
	lo_pool9_7 = (9, 15)
	lo_pool9_5 = (9, 13)
	lo_pool8_3 = (8, 10)
	lo_pool7_4 = (7, 10)
	lo_pool6_4 = (6, 9)
	lo_pool6_3 = (6, 8)
	lo_pool6_1 = (6, 6)
	lo_pool5_4 = (5, 8)
	lo_pool5_1 = (5, 5)
	lo_pool3_9 = (3, 11)
	lo_pool3_7 = (3, 9)
	lo_pool3_3 = (3, 5)
	lo_pool3_2 = (3, 4)
	lo_pool2_2 = (2, 3)
	lo_pool2_1 = (2, 2)
	lo_pool1_1 = (1, 1)
	lo_pool0_5 = (0, 4)
	lo_pool0_3 = (0, 2)
	lo_pool0_2 = (0, 1)
	lo_pool0_1 = (0, 0)
	
	shift = (0, 4)
	
	rd = (11, 15)
	
	sel = (11, 15) # for MFC0

	lo_uimm11_5 = (11, 15)
	lo_uimm0_12 = (0, 11)
	
	lo_simm12_4 = (12, 15)
	lo_simm2_10 = (2, 11)
	lo_simm1_15 = (1, 15)
	lo_simm1_13 = (1, 13)
	lo_simm1_10 = (1, 10)
	lo_simm1_1 = (1, 1)
	lo_signbit0_1 = (0, 0) signed
	;
	
define token data16(16)
	hi_imm16 = (0, 15) signed
	lo_imm16 = (0, 15)
	
	# TODO move/rename any immediate fields that can be mixed with opcode bits
	uimm16 = (0, 15)
	uimm2_14 = (2, 15)
	uimm0_2 = (0, 1)
	;

attach variables [ rt rs rs_from_rt rd ] [
	zero
	at
	t4 t5
	a0 a1 a2 a3
	a4 a5 a6 a7
	t0 t1 t2 t3
	s0 s1 s2 s3
	s4 s5 s6 s7
	t8 t9
	k0 k1
	gp sp fp ra
];

# gpr3: [16, 17, 18, 19, 4, 5, 6, 7]
attach variables [ rt3 rs3 rd3 ] [
	s0 s1 s2 s3
	a0 a1 a2 a3
];

# gpr4: Standard list of 16 GPRs used by 16 bit instructions not in MMS.
# gpr_list = [8, 9, 10, 11, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 23]

# encoding sadness edition :'(
attach variables [ rt4x rs4x rd4x_from_rt4x ] [
	a4 a5 a6 a7
	a0 a1 a2 a3
	_ _ _ _
	_ _ _ _
	s0 s1 s2 s3
	s4 s5 s6 s7
	_ _ _ _
	_ _ _ _
];

################################################################
# Macros
################################################################

# macro setResultFlags(result) {
# 	$(Z_flag) = (result == 0);
# 	$(S_flag) = (result s< 0);
# }
# 
# macro setAddCarryFlags(op1,op2) {
# 	$(C_flag) = (carry(op1,zext($(C_flag))) || carry(op2,op1 + zext($(C_flag))));
# }
# 
# macro setAddFlags(op1,op2) {
# 	$(C_flag) = carry(op1,op2);
# }
# 
# macro setSubtractCarryFlags(op1,op2) {
# 	notC = ~$(C_flag);
# 	$(C_flag) = ((op1 < sext(notC)) || (op2 < (op1 - sext(notC))));
# }
# 
# macro setSubtractFlags(op1,op2) {
# 	$(C_flag) = (op1 < op2);
# }
# 
# macro push16(val16) {
# 	SP = SP - 2;
# 	*:2 SP = val16; 
# }
# 
# macro pop16(ret16) {
# 	ret16 = *:2 SP;
# 	SP = SP + 2; 
# }
# 
# macro push8(val8) {
# 	SP = SP - 1;
# 	ptr:2 = SP;
# 	*:1 ptr = val8; 
# }
# 
# macro pop8(ret8) {
#     ptr:2 = SP;
# 	ret8 = *:1 ptr;
# 	SP = SP + 1; 
# }
# 
# ################################################################
# ixMem8: (IX+simm8)  is IX & simm8								{ ptr:2 = IX + simm8; export *:1 ptr; }
# ixMem8: (IX-val)    is IX & simm8 & sign8=1	[ val = -simm8; ]	{ ptr:2 = IX + simm8; export *:1 ptr; }
# 
# iyMem8: (IY+simm8)  is IY & simm8								{ ptr:2 = IY + simm8; export *:1 ptr; }
# iyMem8: (IY-val)    is IY & simm8 & sign8=1	[ val = -simm8; ]	{ ptr:2 = IY + simm8; export *:1 ptr; }
# 
# Addr16: imm16		is imm16									{ export *:1 imm16; }
# 
# Mem16: (imm16)		is imm16									{ export *:2 imm16; }
# 
# RelAddr8: loc		is simm8  [ loc = inst_next + simm8; ]		{ export *:1 loc; }
# 
# cc: "NZ"            is bits3_3=0x0                              { c:1 = ($(Z_flag) == 0); export c; }
# cc: "Z"             is bits3_3=0x1                              { c:1 = $(Z_flag); export c; }
# cc: "NC"            is bits3_3=0x2                              { c:1 = ($(C_flag) == 0); export c; }
# cc: "C"             is bits3_3=0x3                              { c:1 = $(C_flag); export c; }
# cc: "PO"            is bits3_3=0x4                              { c:1 = ($(PV_flag) == 0); export c; }
# cc: "PE"            is bits3_3=0x5                              { c:1 = $(PV_flag); export c; }
# cc: "P"             is bits3_3=0x6                              { c:1 = ($(S_flag) == 0); export c; }
# cc: "M"             is bits3_3=0x7                              { c:1 = $(S_flag); export c; }
# 
# cc2: "NZ"            is bits3_3=0x4                              { c:1 = ($(Z_flag) == 0); export c; }
# cc2: "Z"             is bits3_3=0x5                              { c:1 = $(Z_flag); export c; }
# cc2: "NC"            is bits3_3=0x6                              { c:1 = ($(C_flag) == 0); export c; }
# cc2: "C"             is bits3_3=0x7                              { c:1 = $(C_flag); export c; }
# ################################################################

buimm7: uimm7 is
	hi_uimm0_2; lo_uimm11_5
	[
		uimm7 = (hi_uimm0_2 << 5) | lo_uimm11_5;
	]
	{
		local tmp:4 = uimm7;
		export tmp;
	}

hi_uaddr5: addr is hi_uimm0_4
	[
		addr = inst_next + (hi_uimm0_4 << 1);
	]
	{
		# TODO effective_address
		export *[ram]:4 addr;
	}

hi_saddr8: addr is
	hi_simm1_6 & hi_signbit0_1
	[
		addr = inst_next + ((hi_signbit0_1 << 7) | (hi_simm1_6 << 1));
	]
	{
		# TODO effective_address
		export *[ram]:4 addr;
	}

hi_saddr11: addr is hi_simm1_9 & hi_signbit0_1
	[
		addr = inst_next + ((hi_signbit0_1 << 10) | (hi_simm1_9 << 1));
	]
	{
		# TODO effective_address
		export *[ram]:4 addr;
	}

lo_saddr12: addr is lo_simm1_10 & lo_signbit0_1
	[
		addr = inst_next + ((lo_signbit0_1 << 11) | (lo_simm1_10 << 1));
	]
	{
		# TODO effective_address
		export *[ram]:4 addr;
	}

lo_saddr15: addr is lo_simm1_13 & lo_signbit0_1
	[
		addr = inst_next + ((lo_signbit0_1 << 14) | (lo_simm1_13 << 1));
	]
	{
		# TODO effective_address
		export *[ram]:4 addr;
	}


# ADD rd, rs, rt
:ADD rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0100010 & lo_pool0_3 = 0b000 {
	rd = rs + rt;
	# TODO: trap on overflow
	# TODO: sign extend?
}

# ADDIU rt, rs, imm
## ADDIU[32]
# TODO: rt != 0 constraint doesn't work here (covered by SIGRIE?)
:ADDIU rt, rs, uimm16 is hi_pool10_6 = 0b000000 & rt & rs; uimm16 {
	rt = rs + uimm16;
}

## ADDIU[48]
:ADDIU rt, rs_from_rt, s32 is hi_pool10_6 = 0b011000 & rt & rs_from_rt & hi_pool0_5 = 0b00001; lo_imm16; hi_imm16
	[s32 = (hi_imm16 << 16) | lo_imm16;] {
	# TODO signedness
	rt = rs_from_rt + s32;
}

## ADDIU[GP48]
# TODO: not available in P64 mode
:ADDIU rt, "gp", s32 is hi_pool10_6 = 0b011000 & rt & hi_pool0_5 = 0b00010; lo_imm16; hi_imm16
	[s32 = (hi_imm16 << 16) | lo_imm16;] {
	# TODO signedness
	# rs = $r28 = gp
	rt = gp + s32;
}

## ADDIU[GP.B]
# TODO: not available in P64 mode
:ADDIU rt, "gp", u18 is hi_pool10_6 = 0b010001 & rt & hi_pool2_3 = 0b011 & hi_uimm0_2; uimm16
	[u18 = (hi_uimm0_2 << 16) | uimm16;] {
	rt = gp + u18;
}

## ADDIU[GP.W]
# TODO: not available in P64 mode
:ADDIU rt, "gp", u21 is hi_pool10_6 = 0b010000 & rt & hi_uimm0_5; uimm2_14 & uimm0_2 = 0b00
	[u21 = (hi_uimm0_5 << 18) | (uimm2_14 << 2);] {
	rt = gp + u21;
}

## ADDIU[R1.SP]
# TODO: not available in P64 mode
:ADDIU rt3, "sp", u8 is hi_pool10_6 = 0b011100 & rt3 & hi_pool6_1 = 0b1 & hi_uimm0_6
	[u8 = hi_uimm0_6 << 2;] {
		rt3 = sp + u8;
}

## ADDIU[R2]
:ADDIU rt3, rs3, u5 is hi_pool10_6 = 0b100100 & rt3 & rs3 & hi_pool3_1 = 0b0 & hi_uimm0_3
	[u5 = hi_uimm0_3 << 2;] {
		rt3 = rs3 + u5;
}

## ADDIU[RS5]
### ADDIU[RS5] with rt=0 is used to provide a 16 bit NOP instruction.
:NOP is hi_pool10_6 = 0b100100 & rt = 0 & hi_pool3_1 = 0b1 {}

# TODO: rt != 0 constraint doesn't work here (OK with NOP rule?)
:ADDIU rt, rs_from_rt, s4 is hi_pool10_6 = 0b100100 & rt & rs_from_rt & hi_simm4_1 & hi_pool3_1 = 0b1 & hi_simm0_3
	[s4 = (hi_simm4_1 << 3) | hi_simm0_3;] {
	rt = rs_from_rt + s4;
	# TODO s4 is signed
}

## ADDIU[NEG]
:ADDIU rt, rs, lo_uimm0_12 is hi_pool10_6 = 0b100000 & rt & rs; lo_pool12_4 = 0b1000 & lo_uimm0_12 {
	rt = rs - lo_uimm0_12;
}

# ADDIUPC rt, imm
## ADDIUPC[32], TODO not available in P64 mode
:ADDIUPC rt, simm22 is hi_pool10_6 = 0b000001 & rt & hi_simm0_5; lo_simm1_15 & lo_signbit0_1
	[simm22 = ((lo_signbit0_1 << 21) | (lo_simm1_15 << 1)) + 4;] {
	# TODO effective_address() - exception on overflowing 32 bits
	rt = inst_next + simm22;
}

## ADDIUPC[48], not available in NMS, TODO not available in P64 mode
:ADDIUPC rt, simm32 is hi_pool10_6 = 0b011000 & rt & hi_pool0_5 = 0b00011; lo_imm16; hi_imm16
	[simm32 = ((hi_imm16 << 16) | lo_imm16) + 6;] {
	# TODO effective_address()
	rt = inst_next + simm32;
}

# ADDU dst, src1, src2
## ADDU[32]
:ADDU rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0101010 & lo_pool0_3 = 0b000 {
	# TODO sign extend sum?
	rd = rs + rt;
}

## ADDU[16]
:ADDU rd3, rs3, rt3 is hi_pool10_6 = 0b101100 & rt3 & rs3 & rd3 & hi_pool0_1 = 0b0 {
	# TODO sign extend sum?
	rd3 = rs3 + rt3;
}

## ADDU[4X4], not available in NMS
:ADDU rd4x_from_rt4x, rt4x, rs4x is hi_pool10_6 = 0b001111 & hi_pool8_1 = 0b0 & rt4x & rd4x_from_rt4x & hi_pool3_1 = 0b0 & rs4x {
	# TODO sign extend sum?
	rd4x_from_rt4x = rt4x + rs4x;
}

# ALUIPC rt, %pcrel_hi(address)
:ALUIPC rt, "%pcrel_hi"(addr) is hi_pool10_6 = 0b111000 & rt & hi_simm0_5;
	lo_simm12_4 & lo_simm2_10 & lo_simm1_1 = 0b1 & lo_signbit0_1
	[addr = (((lo_signbit0_1 << 31) | (lo_simm2_10 << 21) | (hi_simm0_5 << 16) | (lo_simm12_4 << 12)) + inst_next) & ~0xfff;] {
		rt = addr;
}


# BALC address
## BALC[32]
:BALC addr is hi_pool10_6 = 0b001010 & hi_pool9_1 = 0b1 & hi_simm0_9; lo_simm1_15 & lo_signbit0_1
	[addr = ((lo_signbit0_1 << 25) | (hi_simm0_9 << 16) | (lo_simm1_15 << 1)) + inst_next;] {
		# TODO should be effective_address(addr)
		ra = inst_next;
		# TODO make into a call
		pc = addr;
}

## BALC[16]
:BALC hi_saddr11 is hi_pool10_6 = 0b001110 & hi_saddr11 {
		# TODO should be effective_address(addr)
		ra = inst_next;
		call hi_saddr11;
}


# BALRSC rt, rs
:BALRSC rt, rs is hi_pool10_6 = 0b010010 & rt & rt_raw != 0 & rs; lo_pool12_4 = 0b1000 {
	# TODO effective_address
	local addr:4 = 2 * rs + inst_next;
	rt = inst_next;
	# TODO call
	pc = addr;
}


# BBEQZC rt, bit, address
:BBEQZC rt, bitpos, lo_saddr12 is
	hi_pool10_6 = 0b110010 & rt & hi_pool2_3 = 0b001 & hi_uimm0_1;
	lo_uimm11_5 & lo_saddr12
	[
		bitpos = (hi_uimm0_1 << 5) | lo_uimm11_5;
	]
	{
		local testbit:4 = (rt >> bitpos) & 1;
		if (testbit == 0) goto lo_saddr12;
	}


# BBNEZC rt, bit, address
:BBNEZC rt, bitpos, lo_saddr12 is
	hi_pool10_6 = 0b110010 & rt & hi_pool2_3 = 0b101 & hi_uimm0_1;
	lo_uimm11_5 & lo_saddr12
	[
		bitpos = (hi_uimm0_1 << 5) | lo_uimm11_5;
	]
	{
		local testbit:4 = (rt >> bitpos) & 1;
		if (testbit == 1) goto lo_saddr12;
	}


# BEQC rs, rt, address
## BEQC[32]
:BEQC rs, rt, lo_saddr15 is
	hi_pool10_6 = 0b100010 & rt & rs;
	lo_pool14_2 = 0b00 & lo_saddr15
	{
		# TODO "not_in_mms = False" ?
		if (rs == rt) goto lo_saddr15;
	}

## BEQC[16], not available in NMS (with rs3<rt3 && u!=0)
:BEQC rs3, rt3, hi_uaddr5 is
	hi_pool10_6 = 0b110110 & rt3 & rs3 & rs3_raw < rt3_raw & hi_uimm0_4 != 0 & hi_uaddr5
	{
		if (rs3 == rt3) goto hi_uaddr5;
	}


# BEQIC rt, u, address
:BEQIC rt, buimm7, lo_saddr12 is
	(hi_pool10_6 = 0b110010 & rt & hi_pool2_3 = 0b000; lo_saddr12)
	& buimm7
	{
		if (rt == buimm7) goto lo_saddr12;
	}


# BEQZC rt, address
## BEQZC[16]
:BEQZC rt3, hi_saddr8 is
	hi_pool10_6 = 0b100110 & rt3 & hi_saddr8
	{
		if (rt3 == 0) goto hi_saddr8;
	}


# BGEC rs, rt, address
:BGEC rs, rt, lo_saddr15 is
	hi_pool10_6 = 0b100010 & rt & rs;
	lo_pool14_2 = 0b10 & lo_saddr15
	{
		if (rs s>= rt) goto lo_saddr15;
	}


# BGEIC rt, u, address
:BGEIC rt, buimm7, lo_saddr12 is
	(hi_pool10_6 = 0b110010 & rt & hi_pool2_3 = 0b010; lo_saddr12)
	& buimm7
	{
		if (rt s>= buimm7) goto lo_saddr12;
	}


# BGEIUC rt, u, address
:BGEIUC rt, buimm7, lo_saddr12 is
	(hi_pool10_6 = 0b110010 & rt & hi_pool2_3 = 0b011; lo_saddr12)
	& buimm7
	{
		# rt explicitly treated as unsigned
		if (rt >= buimm7) goto lo_saddr12;
	}


# BGEUC rs, rt, address
:BGEUC rs, rt, lo_saddr15 is
	hi_pool10_6 = 0b100010 & rt & rs;
	lo_pool14_2 = 0b11 & lo_saddr15
	{
		# rs & rt explicitly treated as unsigned
		if (rs >= rt) goto lo_saddr15;
	}


# BLTC rs, rt, address
:BLTC rs, rt, lo_saddr15 is
	hi_pool10_6 = 0b101010 & rt & rs;
	lo_pool14_2 = 0b10 & lo_saddr15
	{
		if (rs s< rt) goto lo_saddr15;
	}


# BLTIC rt, u, address
:BLTIC rt, buimm7, lo_saddr12 is
	(hi_pool10_6 = 0b110010 & rt & hi_pool2_3 = 0b110; lo_saddr12)
	& buimm7
	{
		if (rt s< buimm7) goto lo_saddr12;
	}




# LI
## LI[16]
:LI rt3, s is hi_pool10_6 = 0b110100 & rt3 & eu_imm7 = 127 [s = -1;] {
	rt3 = s;
}

:LI rt3, eu_imm7 is hi_pool10_6 = 0b110100 & rt3 & eu_imm7 {
	rt3 = eu_imm7;
} 

## LI[48]
:LI rt, s32 is hi_pool10_6 = 0b011000 & rt & hi_pool0_5 = 0b00000; lo_imm16; hi_imm16 [s32 = (hi_imm16 << 16) | lo_imm16;] {
	rt = s32;
	# TODO: is signedness maintained correctly?
}

# JRC
:JRC rt is hi_pool10_6 = 0b110110 & rt & hi_pool4_1 = 0 & hi_pool0_4 = 0b0000 {
	pc = rt;
}

# AND
## AND rd, rs, rt
:AND rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b1001010 & lo_pool0_3 = 0b000 {
	rd = rs & rt;
}

## AND[16]
:AND rt3, rs3 is hi_pool10_6 = 0b010100 & rt3 & rs3 & hi_pool2_2 = 0b10 & hi_pool1_1 = 0 & hi_pool0_1 = 0 {
	rt3 = rs3 & rt3;
}

# ANDI
## ANDI rt, rs, u
:ANDI rt, rs, lo_uimm0_12 is hi_pool10_6 = 0b100000 & rt & rs; lo_pool12_4 = 0b0010 & lo_uimm0_12 {
	rt = rs & lo_uimm0_12;
}

# ANDI16
## ANDI16 rt, rs, u
:ANDI rt3, rs3, eu_imm4 is hi_pool10_6 = 0b111100 & rt3 & rs3 & eu_imm4 {
	rt3 = rs3 & eu_imm4;
}


# OR
## OR rd, rs, rt
:OR rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b1010010 & lo_pool0_3 = 0b000 {
	rd = rs | rt;
}

## OR[16]
:OR rt3, rs3 is hi_pool10_6 = 0b010100 & rt3 & rs3 & hi_pool2_2 = 0b11 & hi_pool1_1 = 0 & hi_pool0_1 = 0 {
	rt3 = rs3 ^ rt3;
}


# SIGRIE code
# TODO: Signal Reserved Instruction Exception
:SIGRIE code is hi_pool10_6 = 0b000000 & rt = 0 & hi_pool3_2 = 0b00 & hi_uimm0_3; uimm16
	[code = (hi_uimm0_3 << 16) | uimm16;] unimpl


# XOR
## XOR rd, rs, rt
:XOR rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b1100010 & lo_pool0_3 = 0b000 {
	rd = rs ^ rt;
}

## XOR[16]
:XOR rt3, rs3 is hi_pool10_6 = 0b010100 & rt3 & rs3 & hi_pool2_2 = 0b01 & hi_pool1_1 = 0 & hi_pool0_1 = 0 {
	rt3 = rs3 ^ rt3;
}

# LW
## LW rt, offset(rs)
:LW rt, lo_uimm0_12(rs) is hi_pool10_6 = 0b100001 & rt & rs; lo_pool12_4 = 0b1000 & lo_uimm0_12 {
	rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
}

# LW16
## LW16 rt3, offset(rs3)
:LW rt3, u_imm4(rs3) is hi_pool10_6 = 0b000101 & rt3 & rs3 & u_imm4 {
	rt3 = *(rs3 + u_imm4); # TODO: currently updating this to be correct, this is not correct atm
}

# LW[SP]
## LW rt, offset(sp)
:LW rt, off(sp) is hi_pool10_6 = 0b001101 & rt & u_imm5 & sp [off = (u_imm5 * 4);] {
	rt = *(sp + off); # TODO: update this to point to certain regions of space (i.e. ram, etc.), this syntax is seemingly wrong
}

# MFC0
## MFC0 rt, c0s, sel
:MFC0 rt, c0s, sel is hi_pool10_6 = 0b001000 & rt & c0s; sel & lo_pool3_7 = 0b0000110 & lo_pool0_3 = 0b000 {
	#TODO: read register and sign extend
}

# MTC0
## MTC0 rt, c0s, sel
:MTC0 rt, c0s, sel is hi_pool10_6 = 0b001000 & rt & c0s; sel & lo_pool3_7 = 0b0001110 & lo_pool0_3 = 0b000 {
	#TODO: read register and sign extend
}

# MOD
## MOD rd, rs, rt
:MOD rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0101011 & lo_pool0_3 = 0b000 {
	rd = rs % rt;
}

# MOVE
## MOVE rt, rs
:MOVE rt, rs is hi_pool10_6 = 0b000100 & rt & rs {
	rt = rs;
}

# MOVZ
## MOVZ rd, rs, rt
:MOVZ rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool10_1 = 0 & lo_pool3_7 = 0b1000010 & lo_pool0_3 = 0b000 {
	#TODO: work out zero logic with rt
	rd = rs;
}

# MUL
## MUL rd, rs, rt
:MUL rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0000011 & lo_pool0_3 = 0b000 {
	rd = rs * rt;
}

# NOR
## NOR rd, rs, rt
:NOR rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b1011010 & lo_pool0_3 = 0b000 {
	rt = ~(rs | rt);
}

# ROTR
## ROTR rd, rs, shift
:ROTR rt, rs, lo_pool0_5 is hi_pool10_6 = 0b100000 & rt & rs; lo_pool12_4 = 0b1100 & lo_pool5_4 = 0b0110 & lo_pool0_5 {
	# TODO: sign extend
	rt = rs >> lo_pool0_5;
}

# SLL
## SLL rd, rs, shift
:SLL rt, rs, lo_pool0_5 is hi_pool10_6 = 0b100000 & rt & rs; lo_pool12_4 = 0b1100 & lo_pool5_4 = 0b0000 & lo_pool0_5 {
	rt = rs << lo_pool0_5;
}

# SLL
## SLL[16] rt3, rs3, shift
:SLL rt3, rs3, hi_pool0_3 is hi_pool10_6 = 0b001100 & rt3 & rs3 & hi_pool3_1 = 0 & hi_pool0_3 {
	rt3 = rs3 << hi_pool0_3;
}

# SRL
## SRL rd, rs, shift
:SRL rt, rs, lo_pool0_5 is hi_pool10_6 = 0b100000 & rt & rs; lo_pool12_4 = 0b1100 & lo_pool5_4 = 0b0010 & lo_pool0_5 {
    # TODO: incorporate signed extend
	rt = rs >> lo_pool0_5;
}

# SRL
## SRL[16] rt3, rs3, shift
:SRL rt3, rs3, hi_pool0_3 is hi_pool10_6 = 0b001100 & rt3 & rs3 & hi_pool3_1 = 1 & hi_pool0_3 {
	# TODO: incorporate signe extend
	rt3 = rs3 >> hi_pool0_3;
}

# SRA
## SRA rd, rs, shift
:SRA rt, rs, lo_pool0_5 is hi_pool10_6 = 0b100000 & rt & rs; lo_pool12_4 = 0b1100 & lo_pool5_4 = 0b0100 & lo_pool0_5 {
	rt = rs >> lo_pool0_5;
}


# SW
## SW rt, offset(rs)
:SW rt, lo_uimm0_12(rs) is hi_pool10_6 = 0b100001 & rt & rs; lo_pool12_4 = 0b1001 & lo_uimm0_12 {
	*(rs + lo_uimm0_12) = rt; # TODO: currently updating this to be correct, this is not correct atm
}

# SW16
## SW16 rt3, offset(rs3)
## TODO: swap rt3 with rtz3
:SW rt3, u_imm4(rs3) is hi_pool10_6 = 0b100101 & rt3 & rs3 & u_imm4 {
	*(rs3 + u_imm4) = rt3; # TODO: currently updating this to be correct, this is not correct atm
}

# SW[SP]
## SW rt, offset(sp)
:SW rt, off(sp) is hi_pool10_6 = 0b101101 & rt & u_imm5 & sp [off = (u_imm5 * 4);] {
	*(sp + off) = rt; # TODO: update this to point to certain regions of space (i.e. ram, etc.), this syntax is seemingly wrong
}

# SAVE
## SAVE[16] u, [ src1 [, src2 [ ..,]]
## TODO: figure out how to display registers (seems complicated)
:SAVE is hi_pool10_6 = 0b000111 & rt1 & hi_pool8_1 = 0 &  u_imm4_4 & u_imm4 {

}

# SAVE
## SAVE[32] u, [ src1 [, src2 [ ..,]]
## TODO: figure out how to display registers (seems complicated)
:SAVE is hi_pool10_6 = 0b100000  & rt & hi_pool4_1 = 0 & hi_pool0_4; lo_pool12_4 = 0b0011 & lo_pool3_9 = 0 & lo_pool2_1 & lo_pool0_2 = 0b00 {

}

# RESTORE.JRC
## RESTORE>JRC[16] u, [ src1 [, src2 [ ..,]]
## TODO: figure out how to display registers (seems complicated)
:RESTORE.JRC is hi_pool10_6 = 0b000111 & rt1 & hi_pool8_1 = 1 &  u_imm4_4 & u_imm4 {

}

# RESTORE
## RESTORE[32] u, [ src1 [, src2 [ ..,]]
## TODO: figure out how to display registers (seems complicated)
:RESTORE is hi_pool10_6 = 0b100000  & rt & hi_pool4_1 = 0 & hi_pool0_4; lo_pool12_4 = 0b0011 & lo_pool3_9 = 0 & lo_pool2_1 & lo_pool0_2 = 0b10 {

}

# RESTORE
## RESTORE.JRC[32] u, [ src1 [, src2 [ ..,]]
## TODO: figure out how to display registers (seems complicated)
:RESTORE.JRC is hi_pool10_6 = 0b100000  & rt & hi_pool4_1 & hi_pool0_4; lo_pool12_4 = 0b0011 & lo_pool3_9 = 0 & lo_pool2_1 & lo_pool0_2 = 0b11 {

}






