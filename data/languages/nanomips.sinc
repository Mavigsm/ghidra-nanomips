# sleigh include file for Skeleton language instructions

define token instrhi(16)
	# opcode bits
	hi_pool10_6 = (10, 15)  # MAJOR / P32 / P16
	hi_pool9_1 = (9, 9)
	hi_pool8_1 = (8, 8)
	hi_pool6_1 = (6, 6)
	hi_pool5_5 = (5, 9)
	hi_pool4_1 = (4, 4)
	hi_pool3_2 = (3, 4)
	hi_pool3_1 = (3, 3)
	hi_pool2_3 = (2, 4)
	hi_pool2_2 = (2, 3)
	hi_pool2_1 = (2, 2)
	hi_pool1_2 = (1, 2)
	hi_pool1_1 = (1, 1)
	hi_pool0_5 = (0, 4)  # P48I, P.BR3A
	hi_pool0_4 = (0, 3)  # P16.BR u[4:1]
	hi_pool0_3 = (0, 2)
	hi_pool0_2 = (0, 1)
	hi_pool0_1 = (0, 0)
	
	hint = (5, 9)  # hi_pool5_5
	
	u4_1 = (0, 4)  # u[4:1] - naming convention conflict
	
	# normal register encodings
	rt = (5, 9)
	rt_raw = (5, 9)  # :'(
	rs_from_rt = (5, 9)  # :'(
	rs = (0, 4)
	
	c0s = (0, 4) # for MFC0

	# 1 bit register encodings
	rt1 = (9, 9)

	# 3 bit register encodings
	rt3 = (7, 9)
	rt3_raw = (7, 9)
	rd3_from_rt3 = (7, 9)
	rtz3 = (7, 9)

	rs3 = (4, 6)
	rs3_raw = (4, 6)

	rd3 = (1, 3)

	# 4 bit register encodings
	# disjointed msb requires group per possible bit value (see issue #4140)
	rt4_msb0 = (5, 7)
	rt4_msb1 = (5, 7)
	rd4_from_rt4_msb0 = (5, 7)
	rd4_from_rt4_msb1 = (5, 7)

	rs4_msb0 = (0, 2)
	rs4_msb1 = (0, 2)

	# data in same token as opcode bits
	eu_imm7 = (0, 6)
	hi_uimm1_2 = (1, 2)
	hi_uimm0_10 = (0, 9)
	hi_uimm0_2 = (0, 1)
	hi_uimm0_5 = (0, 4)
	hi_uimm0_6 = (0, 5)
	hi_uimm0_4 = (0, 3)
	hi_uimm0_3 = (0, 2)
	hi_uimm0_1 = (0, 0)

	hi_simm4_1 = (4, 4)
	hi_simm1_6 = (1, 6)
	hi_simm1_9 = (1, 9)
	hi_simm0_9 = (0, 8)
	hi_simm0_5 = (0, 4)
	hi_simm0_3 = (0, 2)
	hi_simm0_1 = (0, 0)
	hi_signbit0_1 = (0, 0) signed

	u_imm5 = (0, 4)
	eu_imm4 = (0, 3)
	u_imm4_4 = (4, 7)
	u_imm4 = (0, 3)
	;
	
define token instrlo(16)
	# opcode bits
	lo_pool15_1 = (15, 15)
	lo_pool14_2 = (14, 15)
	lo_pool12_4 = (12, 15)
	lo_pool12_3 = (12, 14)
	lo_pool11_5 = (11, 15)
	lo_pool11_4 = (11, 14)
	lo_pool11_1 = (11, 11)
	lo_pool10_3 = (10, 12)
	lo_pool10_1 = (10, 10)
	lo_pool9_7 = (9, 15)
	lo_pool9_5 = (9, 13)
	lo_pool9_2 = (9, 10)
	lo_pool8_3 = (8, 10)
	lo_pool8_2 = (8, 9)
	lo_pool7_4 = (7, 10)
	lo_pool6_4 = (6, 9)
	lo_pool6_3 = (6, 8)
	lo_pool6_1 = (6, 6)
	lo_pool5_4 = (5, 8)
	lo_pool5_1 = (5, 5)
	lo_pool3_9 = (3, 11)
	lo_pool3_7 = (3, 9)
	lo_pool3_5 = (3, 7)
	lo_pool3_3 = (3, 5)
	lo_pool3_2 = (3, 4)
	lo_pool2_14 = (2, 15)
	lo_pool2_10 = (2, 11)
	lo_pool2_6 = (2, 7)
	lo_pool2_2 = (2, 3)
	lo_pool2_1 = (2, 2)
	lo_pool1_15 = (1, 15)
	lo_pool1_1 = (1, 1)
	lo_pool0_16 = (0, 15)
	lo_pool0_12 = (0, 11)
	lo_pool0_8 = (0, 7)
	lo_pool0_5 = (0, 4)
	lo_pool0_3 = (0, 2)
	lo_pool0_2 = (0, 1)
	lo_pool0_1 = (0, 0)
	
	shift = (0, 4)
	
	rd = (11, 15)
	
	sel = (11, 15) # for MFC0

	count3 = (12, 14)

	# data in same token as opcode bits
	lo_uimm11_5 = (11, 15)
	lo_uimm1_15 = (1, 15)
	lo_uimm0_12 = (0, 11)
	
	lo_simm12_4 = (12, 15)
	lo_simm2_10 = (2, 11)
	lo_simm1_15 = (1, 15)
	lo_simm1_13 = (1, 13)
	lo_simm1_10 = (1, 10)
	lo_simm1_1 = (1, 1)
	lo_simm0_8 = (0, 7)

	lo_signbit15_1 = (15, 15) signed
	lo_signbit0_1 = (0, 0) signed
	;
	
define token data16(16)
	hi_imm16 = (0, 15) signed
	lo_imm16 = (0, 15)
	
	# TODO move/rename any immediate fields that can be mixed with opcode bits
	uimm16 = (0, 15)
	uimm2_14 = (2, 15)
	uimm0_2 = (0, 1)
	;

attach variables [ rt rs rs_from_rt rd ] [
	zero
	at
	t4 t5
	a0 a1 a2 a3
	a4 a5 a6 a7
	t0 t1 t2 t3
	s0 s1 s2 s3
	s4 s5 s6 s7
	t8 t9
	k0 k1
	gp sp fp ra
];

# gpr3: [16, 17, 18, 19, 4, 5, 6, 7]
attach variables [ rt3 rs3 rd3 rd3_from_rt3 ] [
	s0 s1 s2 s3
	a0 a1 a2 a3
];

# gpr3.src.store: [0, 17, 18, 19, 4, 5, 6, 7]
attach variables [ rtz3 ] [
	zero s1 s2 s3
	a0 a1 a2 a3
];

# gpr4: Standard list of 16 GPRs used by 16 bit instructions not in MMS.
# gpr_list = [8, 9, 10, 11, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 23]

# encoding sadness edition :'(
attach variables [ rt4_msb0 rs4_msb0 rd4_from_rt4_msb0 ] [
	a4 a5 a6 a7
	a0 a1 a2 a3
];

attach variables [ rt4_msb1 rs4_msb1 rd4_from_rt4_msb1 ] [
	s0 s1 s2 s3
	s4 s5 s6 s7
];

attach values [count3] [8 1 2 3 4 5 6 7];

################################################################
# Macros
################################################################

# macro setResultFlags(result) {
# 	$(Z_flag) = (result == 0);
# 	$(S_flag) = (result s< 0);
# }
# 
# macro setAddCarryFlags(op1,op2) {
# 	$(C_flag) = (carry(op1,zext($(C_flag))) || carry(op2,op1 + zext($(C_flag))));
# }
# 
# macro setAddFlags(op1,op2) {
# 	$(C_flag) = carry(op1,op2);
# }
# 
# macro setSubtractCarryFlags(op1,op2) {
# 	notC = ~$(C_flag);
# 	$(C_flag) = ((op1 < sext(notC)) || (op2 < (op1 - sext(notC))));
# }
# 
# macro setSubtractFlags(op1,op2) {
# 	$(C_flag) = (op1 < op2);
# }
# 
# macro push16(val16) {
# 	SP = SP - 2;
# 	*:2 SP = val16; 
# }
# 
# macro pop16(ret16) {
# 	ret16 = *:2 SP;
# 	SP = SP + 2; 
# }
# 
# macro push8(val8) {
# 	SP = SP - 1;
# 	ptr:2 = SP;
# 	*:1 ptr = val8; 
# }
# 
# macro pop8(ret8) {
#     ptr:2 = SP;
# 	ret8 = *:1 ptr;
# 	SP = SP + 1; 
# }
# 
# ################################################################
# ixMem8: (IX+simm8)  is IX & simm8								{ ptr:2 = IX + simm8; export *:1 ptr; }
# ixMem8: (IX-val)    is IX & simm8 & sign8=1	[ val = -simm8; ]	{ ptr:2 = IX + simm8; export *:1 ptr; }
# 
# iyMem8: (IY+simm8)  is IY & simm8								{ ptr:2 = IY + simm8; export *:1 ptr; }
# iyMem8: (IY-val)    is IY & simm8 & sign8=1	[ val = -simm8; ]	{ ptr:2 = IY + simm8; export *:1 ptr; }
# 
# Addr16: imm16		is imm16									{ export *:1 imm16; }
# 
# Mem16: (imm16)		is imm16									{ export *:2 imm16; }
# 
# RelAddr8: loc		is simm8  [ loc = inst_next + simm8; ]		{ export *:1 loc; }
# 
# cc: "NZ"            is bits3_3=0x0                              { c:1 = ($(Z_flag) == 0); export c; }
# cc: "Z"             is bits3_3=0x1                              { c:1 = $(Z_flag); export c; }
# cc: "NC"            is bits3_3=0x2                              { c:1 = ($(C_flag) == 0); export c; }
# cc: "C"             is bits3_3=0x3                              { c:1 = $(C_flag); export c; }
# cc: "PO"            is bits3_3=0x4                              { c:1 = ($(PV_flag) == 0); export c; }
# cc: "PE"            is bits3_3=0x5                              { c:1 = $(PV_flag); export c; }
# cc: "P"             is bits3_3=0x6                              { c:1 = ($(S_flag) == 0); export c; }
# cc: "M"             is bits3_3=0x7                              { c:1 = $(S_flag); export c; }
# 
# cc2: "NZ"            is bits3_3=0x4                              { c:1 = ($(Z_flag) == 0); export c; }
# cc2: "Z"             is bits3_3=0x5                              { c:1 = $(Z_flag); export c; }
# cc2: "NC"            is bits3_3=0x6                              { c:1 = ($(C_flag) == 0); export c; }
# cc2: "C"             is bits3_3=0x7                              { c:1 = $(C_flag); export c; }
# ################################################################

# disjointed register encodings
rt4: rt4_msb0 is hi_pool9_1 = 0b0 & rt4_msb0 {export rt4_msb0;}
rt4: rt4_msb1 is hi_pool9_1 = 0b1 & rt4_msb1 {export rt4_msb1;}

rd4_from_rt4: rd4_from_rt4_msb0 is hi_pool9_1 = 0b0 & rd4_from_rt4_msb0 {export rd4_from_rt4_msb0;}
rd4_from_rt4: rd4_from_rt4_msb1 is hi_pool9_1 = 0b1 & rd4_from_rt4_msb1 {export rd4_from_rt4_msb1;}

rs4: rs4_msb0 is hi_pool4_1 = 0b0 & rs4_msb0 {export rs4_msb0;}
rs4: rs4_msb1 is hi_pool4_1 = 0b1 & rs4_msb1 {export rs4_msb1;}


rs_scale2: rs is rs
	{
		# TODO effective_address
		local addr:4 = rs * 2 + inst_next;
		export *[ram]:4 addr;
	}

buimm7: uimm7 is
	hi_uimm0_2; lo_uimm11_5
	[
		uimm7 = (hi_uimm0_2 << 5) | lo_uimm11_5;
	]
	{
		local tmp:4 = uimm7;
		export tmp;
	}

hilo_saddr26: addr is
	 hi_simm0_9; lo_simm1_15 & lo_signbit0_1
	[
		addr = inst_next + ((lo_signbit0_1 << 25) | (hi_simm0_9 << 16) | (lo_simm1_15 << 1));
	]
	{
		# TODO should be effective_address(addr)
		export *[ram]:4 addr;
	}

hi_uaddr5: addr is hi_uimm0_4
	[
		addr = inst_next + (hi_uimm0_4 << 1);
	]
	{
		# TODO effective_address
		export *[ram]:4 addr;
	}

hi_saddr8: addr is
	hi_simm1_6 & hi_signbit0_1
	[
		addr = inst_next + ((hi_signbit0_1 << 7) | (hi_simm1_6 << 1));
	]
	{
		# TODO effective_address
		export *[ram]:4 addr;
	}

hi_saddr11: addr is hi_simm1_9 & hi_signbit0_1
	[
		addr = inst_next + ((hi_signbit0_1 << 10) | (hi_simm1_9 << 1));
	]
	{
		# TODO effective_address
		export *[ram]:4 addr;
	}

lo_saddr12: addr is lo_simm1_10 & lo_signbit0_1
	[
		addr = inst_next + ((lo_signbit0_1 << 11) | (lo_simm1_10 << 1));
	]
	{
		# TODO effective_address
		export *[ram]:4 addr;
	}

lo_saddr15: addr is lo_simm1_13 & lo_signbit0_1
	[
		addr = inst_next + ((lo_signbit0_1 << 14) | (lo_simm1_13 << 1));
	]
	{
		# TODO effective_address
		export *[ram]:4 addr;
	}

lo_soffset9: offs is lo_signbit15_1 & lo_simm0_8
	[
		offs = (lo_signbit15_1 << 8) | lo_simm0_8;
	]
	{
		local tmp:4 = offs;
		export tmp;
	}

hilo_gp_uoffset18: offs("gp") is
	hi_uimm0_2; lo_uimm1_15
	[
		offs = (hi_uimm0_2 << 16) | (lo_uimm1_15 << 1);
	]
	{
		local addr = gp + offs;
		export *[ram]:4 addr;
	}

hi_rs3_uoffset6: offs(rs3) is
	rs3 & hi_uimm0_4
	[
		offs = hi_uimm0_4 << 2;
	]
	{
		local addr = rs3 + offs;
		export *[ram]:4 addr;
	}

hi_rs3_uoffset3: offs(rs3) is
	rs3 & hi_uimm1_2
	[
		offs = hi_uimm1_2 << 1;
	]
	{
		local addr = rs3 + offs;
		export *[ram]:4 addr;
	}

lo_rs_uoffset12: lo_uimm0_12(rs) is
	rs; lo_uimm0_12
	{
		local addr = rs + lo_uimm0_12;
		export *[ram]:4 addr;
	}

lo_rs_soffset9: lo_soffset9(rs) is
	rs; lo_soffset9
	{
		local addr = rs + lo_soffset9;
		export *[ram]:4 addr;
	}


# ADD rd, rs, rt
:ADD rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0100010 & lo_pool0_3 = 0b000 {
	rd = rs + rt;
	# TODO: trap on overflow
	# TODO: sign extend?
}

# ADDIU rt, rs, imm
## ADDIU[32]
# TODO: rt != 0 constraint doesn't work here (covered by SIGRIE?)
:ADDIU rt, rs, uimm16 is hi_pool10_6 = 0b000000 & rt & rs; uimm16 {
	rt = rs + uimm16;
}

## ADDIU[48]
:ADDIU rt, rs_from_rt, s32 is hi_pool10_6 = 0b011000 & rt & rs_from_rt & hi_pool0_5 = 0b00001; lo_imm16; hi_imm16
	[s32 = (hi_imm16 << 16) | lo_imm16;] {
	# TODO signedness
	rt = rs_from_rt + s32;
}

## ADDIU[GP48]
# TODO: not available in P64 mode
:ADDIU rt, "gp", s32 is hi_pool10_6 = 0b011000 & rt & hi_pool0_5 = 0b00010; lo_imm16; hi_imm16
	[s32 = (hi_imm16 << 16) | lo_imm16;] {
	# TODO signedness
	# rs = $r28 = gp
	rt = gp + s32;
}

## ADDIU[GP.B]
# TODO: not available in P64 mode
:ADDIU rt, "gp", u18 is hi_pool10_6 = 0b010001 & rt & hi_pool2_3 = 0b011 & hi_uimm0_2; uimm16
	[u18 = (hi_uimm0_2 << 16) | uimm16;] {
	rt = gp + u18;
}

## ADDIU[GP.W]
# TODO: not available in P64 mode
:ADDIU rt, "gp", u21 is hi_pool10_6 = 0b010000 & rt & hi_uimm0_5; uimm2_14 & uimm0_2 = 0b00
	[u21 = (hi_uimm0_5 << 18) | (uimm2_14 << 2);] {
	rt = gp + u21;
}

## ADDIU[R1.SP]
# TODO: not available in P64 mode
:ADDIU rt3, "sp", u8 is hi_pool10_6 = 0b011100 & rt3 & hi_pool6_1 = 0b1 & hi_uimm0_6
	[u8 = hi_uimm0_6 << 2;] {
		rt3 = sp + u8;
}

## ADDIU[R2]
:ADDIU rt3, rs3, u5 is hi_pool10_6 = 0b100100 & rt3 & rs3 & hi_pool3_1 = 0b0 & hi_uimm0_3
	[u5 = hi_uimm0_3 << 2;] {
		rt3 = rs3 + u5;
}

## ADDIU[RS5]
### ADDIU[RS5] with rt=0 is used to provide a 16 bit NOP instruction.
:NOP is hi_pool10_6 = 0b100100 & rt = 0 & hi_pool3_1 = 0b1 {}

# TODO: rt != 0 constraint doesn't work here (OK with NOP rule?)
:ADDIU rt, rs_from_rt, s4 is hi_pool10_6 = 0b100100 & rt & rs_from_rt & hi_simm4_1 & hi_pool3_1 = 0b1 & hi_simm0_3
	[s4 = (hi_simm4_1 << 3) | hi_simm0_3;] {
	rt = rs_from_rt + s4;
	# TODO s4 is signed
}

## ADDIU[NEG]
:ADDIU rt, rs, lo_uimm0_12 is hi_pool10_6 = 0b100000 & rt & rs; lo_pool12_4 = 0b1000 & lo_uimm0_12 {
	rt = rs - lo_uimm0_12;
}

# ADDIUPC rt, imm
## ADDIUPC[32], TODO not available in P64 mode
:ADDIUPC rt, simm22 is hi_pool10_6 = 0b000001 & rt & hi_simm0_5; lo_simm1_15 & lo_signbit0_1
	[simm22 = ((lo_signbit0_1 << 21) | (lo_simm1_15 << 1)) + 4;] {
	# TODO effective_address() - exception on overflowing 32 bits
	rt = inst_next + simm22;
}

## ADDIUPC[48], not available in NMS, TODO not available in P64 mode
:ADDIUPC rt, simm32 is hi_pool10_6 = 0b011000 & rt & hi_pool0_5 = 0b00011; lo_imm16; hi_imm16
	[simm32 = ((hi_imm16 << 16) | lo_imm16) + 6;] {
	# TODO effective_address()
	rt = inst_next + simm32;
}

# ADDU dst, src1, src2
## ADDU[32]
:ADDU rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0101010 & lo_pool0_3 = 0b000 {
	# TODO sign extend sum?
	rd = rs + rt;
}

## ADDU[16]
:ADDU rd3, rs3, rt3 is hi_pool10_6 = 0b101100 & rt3 & rs3 & rd3 & hi_pool0_1 = 0b0 {
	# TODO sign extend sum?
	rd3 = rs3 + rt3;
}

## ADDU[4X4], not available in NMS
:ADDU rd4_from_rt4, rt4, rs4 is
	hi_pool10_6 = 0b001111 & hi_pool8_1 = 0b0 & rt4 & rd4_from_rt4 & hi_pool3_1 = 0b0 & rs4
	{
		# TODO sign extend sum?
		rd4_from_rt4 = rt4 + rs4;
	}

# AND
## AND rd, rs, rt
:AND rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b1001010 & lo_pool0_3 = 0b000 {
	rd = rs & rt;
}

## AND[16]
:AND rt3, rs3 is hi_pool10_6 = 0b010100 & rt3 & rs3 & hi_pool2_2 = 0b10 & hi_pool1_1 = 0 & hi_pool0_1 = 0 {
	rt3 = rs3 & rt3;
}

# ANDI
## ANDI rt, rs, u
:ANDI rt, rs, lo_uimm0_12 is hi_pool10_6 = 0b100000 & rt & rs; lo_pool12_4 = 0b0010 & lo_uimm0_12 {
	rt = rs & lo_uimm0_12;
}

# ANDI16
## ANDI16 rt, rs, u
:ANDI rt3, rs3, eu_imm4 is hi_pool10_6 = 0b111100 & rt3 & rs3 & eu_imm4 {
	rt3 = rs3 & eu_imm4;
}

# ALUIPC rt, %pcrel_hi(address)
:ALUIPC rt, "%pcrel_hi"(addr) is hi_pool10_6 = 0b111000 & rt & hi_simm0_5;
	lo_simm12_4 & lo_simm2_10 & lo_simm1_1 = 0b1 & lo_signbit0_1
	[addr = (((lo_signbit0_1 << 31) | (lo_simm2_10 << 21) | (hi_simm0_5 << 16) | (lo_simm12_4 << 12)) + inst_next) & ~0xfff;] {
		rt = addr;
}


# BALC address
## BALC[32]
:BALC hilo_saddr26 is
	(hi_pool10_6 = 0b001010 & hi_pool9_1 = 0b1) ... & hilo_saddr26
	{
		ra = inst_next;
		call hilo_saddr26;
	}

## BALC[16]
:BALC hi_saddr11 is
	hi_pool10_6 = 0b001110 & hi_saddr11
	{
		ra = inst_next;
		call hi_saddr11;
	}


# BALRSC rt, rs
:BALRSC rt, rs_scale2 is
	hi_pool10_6 = 0b010010 & rt & rt_raw != 0 & rs_scale2;
	lo_pool12_4 = 0b1000
	{
		rt = inst_next;
		call rs_scale2;
	}


# BBEQZC rt, bit, address
:BBEQZC rt, bitpos, lo_saddr12 is
	hi_pool10_6 = 0b110010 & rt & hi_pool2_3 = 0b001 & hi_uimm0_1;
	lo_uimm11_5 & lo_saddr12
	[
		bitpos = (hi_uimm0_1 << 5) | lo_uimm11_5;
	]
	{
		local testbit:4 = (rt >> bitpos) & 1;
		if (testbit == 0) goto lo_saddr12;
	}


# BBNEZC rt, bit, address
:BBNEZC rt, bitpos, lo_saddr12 is
	hi_pool10_6 = 0b110010 & rt & hi_pool2_3 = 0b101 & hi_uimm0_1;
	lo_uimm11_5 & lo_saddr12
	[
		bitpos = (hi_uimm0_1 << 5) | lo_uimm11_5;
	]
	{
		local testbit:4 = (rt >> bitpos) & 1;
		if (testbit == 1) goto lo_saddr12;
	}

# BC address
## BC[32]
:BC addr is hi_pool10_6 = 0b001010 & hi_pool9_1 = 0b0 & hi_simm0_9; lo_simm1_15 & lo_signbit0_1
	[addr = ((lo_signbit0_1 << 25) | (hi_simm0_9 << 16) | (lo_simm1_15 << 1)) + inst_next;] {
		# TODO should be effective_address(addr)
		ra = inst_next;
		# TODO make into a call
		pc = addr;
}

## BC[16]
:BC hi_saddr11 is hi_pool10_6 = 0b000110 & hi_saddr11 {
		# TODO should be effective_address(addr)
		ra = inst_next;
		call hi_saddr11;
}


# BEQC rs, rt, address
## BEQC[32]
:BEQC rs, rt, lo_saddr15 is
	hi_pool10_6 = 0b100010 & rt & rs;
	lo_pool14_2 = 0b00 & lo_saddr15
	{
		# TODO "not_in_mms = False" ?
		if (rs == rt) goto lo_saddr15;
	}

## BEQC[16], not available in NMS (with rs3<rt3 && u!=0)
:BEQC rs3, rt3, hi_uaddr5 is
	hi_pool10_6 = 0b110110 & rt3 & rs3 & rs3_raw < rt3_raw & hi_uimm0_4 != 0 & hi_uaddr5
	{
		if (rs3 == rt3) goto hi_uaddr5;
	}


# BEQIC rt, u, address
:BEQIC rt, buimm7, lo_saddr12 is
	(hi_pool10_6 = 0b110010 & rt & hi_pool2_3 = 0b000; lo_saddr12)
	& buimm7
	{
		if (rt == buimm7) goto lo_saddr12;
	}


# BEQZC rt, address
## BEQZC[16]
:BEQZC rt3, hi_saddr8 is
	hi_pool10_6 = 0b100110 & rt3 & hi_saddr8
	{
		if (rt3 == 0) goto hi_saddr8;
	}


# BGEC rs, rt, address
:BGEC rs, rt, lo_saddr15 is
	hi_pool10_6 = 0b100010 & rt & rs;
	lo_pool14_2 = 0b10 & lo_saddr15
	{
		if (rs s>= rt) goto lo_saddr15;
	}


# BGEIC rt, u, address
:BGEIC rt, buimm7, lo_saddr12 is
	(hi_pool10_6 = 0b110010 & rt & hi_pool2_3 = 0b010; lo_saddr12)
	& buimm7
	{
		if (rt s>= buimm7) goto lo_saddr12;
	}


# BGEIUC rt, u, address
:BGEIUC rt, buimm7, lo_saddr12 is
	(hi_pool10_6 = 0b110010 & rt & hi_pool2_3 = 0b011; lo_saddr12)
	& buimm7
	{
		# rt explicitly treated as unsigned
		if (rt >= buimm7) goto lo_saddr12;
	}


# BGEUC rs, rt, address
:BGEUC rs, rt, lo_saddr15 is
	hi_pool10_6 = 0b100010 & rt & rs;
	lo_pool14_2 = 0b11 & lo_saddr15
	{
		# rs & rt explicitly treated as unsigned
		if (rs >= rt) goto lo_saddr15;
	}


# BLTC rs, rt, address
:BLTC rs, rt, lo_saddr15 is
	hi_pool10_6 = 0b101010 & rt & rs;
	lo_pool14_2 = 0b10 & lo_saddr15
	{
		if (rs s< rt) goto lo_saddr15;
	}


# BLTIC rt, u, address
:BLTIC rt, buimm7, lo_saddr12 is
	(hi_pool10_6 = 0b110010 & rt & hi_pool2_3 = 0b110; lo_saddr12)
	& buimm7
	{
		if (rt s< buimm7) goto lo_saddr12;
	}


# BLTIUC rt, u, address
:BLTIUC rt, buimm7, lo_saddr12 is
	(hi_pool10_6 = 0b110010 & rt & hi_pool2_3 = 0b111; lo_saddr12)
	& buimm7
	{
		# rt explicitly treated as unsigned
		if (rt < buimm7) goto lo_saddr12;
	}


# BLTUC rs, rt, address
:BLTUC rs, rt, lo_saddr15 is
	hi_pool10_6 = 0b101010 & rt & rs;
	lo_pool14_2 = 0b11 & lo_saddr15
	{
		# rs/rt explicitly unsigned
		if (rs < rt) goto lo_saddr15;
	}


# BNEC rs, rt, address
## BNEC[32]
:BNEC rs, rt, lo_saddr15 is
	hi_pool10_6 = 0b101010 & rt & rs;
	lo_pool14_2 = 0b00 & lo_saddr15
	{
		if (rs != rt) goto lo_saddr15;
	}

## BNEC[16], not available in NMS
:BNEC rs3, rt3, hi_uaddr5 is
	hi_pool10_6 = 0b110110 & rt3 & rs3 & rs3_raw >= rt3_raw & hi_uimm0_4 != 0 & hi_uaddr5
	{
		if (rs3 != rt3) goto hi_uaddr5;
	}


# BNEIC rt, u, address
:BNEIC rt, buimm7, lo_saddr12 is
	(hi_pool10_6 = 0b110010 & rt & hi_pool2_3 = 0b100; lo_saddr12)
	& buimm7
	{
		if (rt != buimm7) goto lo_saddr12;
	}


# BNEZC rt, address
## BNEZC[16]
:BNEZC rt3, hi_saddr8 is
	hi_pool10_6 = 0b101110 & rt3 & hi_saddr8
	{
		if (rt3 != 0) goto hi_saddr8;
	}


# BREAK code
## BREAK[32]
:BREAK code is
	hi_pool10_6 = 0b000000 & rt = 0 & hi_pool3_2 = 0b10 & hi_uimm0_3;
	uimm16
	[
		code = (hi_uimm0_3 << 16) | uimm16;
	]
	unimpl # TODO raise breakpoint exception ("BP")

## BREAK[16]
:BREAK hi_uimm0_3 is
	hi_pool10_6 = 0b000100 & rt = 0 & hi_pool3_2 = 0b10 & hi_uimm0_3
	unimpl # TODO raise breakpoint exception ("BP")


# BRSC rs
:BRSC rs_scale2 is
	hi_pool10_6 = 0b010010 & rt = 0 & rs_scale2;
	lo_pool12_4 = 0b1000
	{
		goto rs_scale2;
	}


# CACHE/CACHEE op, offset(rs)
# TODO "Requires CP0 privilege, availability varies by format."

## CACHE
:CACHE rt_raw, lo_soffset9(rs) is
	hi_pool10_6 = 0b101001 & rt_raw & rs;
	lo_pool11_4 = 0b0111 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b01 & lo_soffset9
	unimpl

## CACHEE, present when Config5.EVA=1.
:CACHEE rt_raw, lo_soffset9(rs) is
	hi_pool10_6 = 0b101001 & rt_raw & rs;
	lo_pool11_4 = 0b0111 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10 & lo_soffset9
	unimpl

# CLO rt, rs
:CLO rt, rs is
	hi_pool10_6 = 0b001000 & rt & rs;
	lo_pool9_7 = 0b0100101 & lo_pool6_3 = 0b100 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	{
		# count leading 1s
		rt = lzcount(~rs);
	}

# CLZ
## CLZ rt, rs
:CLZ rt, rs is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool9_7 = 0b0101101 & lo_pool6_3 = 0b100 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111 {
	rt = lzcount(rs);
}

# CRC32B
## CRC32B rt, rs
:CRC32B rt, rs is hi_pool10_6 = 0b001000 & rt & rs; lo_pool10_3 = 0b000 & lo_pool6_4 = 0b1111 & lo_pool5_1 = 0b1 & lo_pool3_2 = 0b01 & lo_pool0_3 = 0b000 {
	# TODO: figure out how to implement this
	rt = sext(rs);
}

# CRC32CB
## CRC32CB rt, rs
:CRC32CB rt, rs is hi_pool10_6 = 0b001000 & rt & rs; lo_pool10_3 = 0b100 & lo_pool6_4 = 0b1111 & lo_pool5_1 = 0b1 & lo_pool3_2 = 0b01 & lo_pool0_3 = 0b000 {
	# TODO: figure out how to implement this
	rt = sext(rs);
}

# CRC32CH
## CRC32CH rt, rs
:CRC32CH rt, rs is hi_pool10_6 = 0b001000 & rt & rs; lo_pool10_3 = 0b101 & lo_pool6_4 = 0b1111 & lo_pool5_1 = 0b1 & lo_pool3_2 = 0b01 & lo_pool0_3 = 0b000 {
	# TODO: figure out how to implement this
	rt = sext(rs);
}

# CRC32CW
## CRC32CW rt, rs
:CRC32CW rt, rs is hi_pool10_6 = 0b001000 & rt & rs; lo_pool10_3 = 0b110 & lo_pool6_4 = 0b1111 & lo_pool5_1 = 0b1 & lo_pool3_2 = 0b01 & lo_pool0_3 = 0b000 {
	# TODO: figure out how to implement this
	rt = sext(rs);
}

# CRC32H
## CRC32H rt, rs
:CRC32H rt, rs is hi_pool10_6 = 0b001000 & rt & rs; lo_pool10_3 = 0b001 & lo_pool6_4 = 0b1111 & lo_pool5_1 = 0b1 & lo_pool3_2 = 0b01 & lo_pool0_3 = 0b000 {
	# TODO: figure out how to implement this
	rt = sext(rs);
}

# CRC32W
## CRC32W rt, rs
:CRC32W rt, rs is hi_pool10_6 = 0b001000 & rt & rs; lo_pool10_3 = 0b010 & lo_pool6_4 = 0b1111 & lo_pool5_1 = 0b1 & lo_pool3_2 = 0b01 & lo_pool0_3 = 0b000 {
	# TODO: figure out how to implement this
	rt = sext(rs);
}

# DERET
## DERET rt, rs
:DERET is hi_pool10_6 = 0b001000; lo_pool14_2 = 0b11 & lo_pool9_5 = 0b10001 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111 {
	# TODO: Just doing the bit pattern for now

}

# DI
## DI rt
:DI is hi_pool10_6 = 0b001000 & rt; lo_pool14_2 = 0b01 & lo_pool9_5 = 0b00011 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111 {
	# TODO: Just doing the bit pattern for now

}

# DIV
## DIV rd, rs, rt
:DIV is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0100011 & lo_pool0_3 = 0b000 {
	# TODO: Verify correct to sign extend for 32 bit value
	# TODO: implement signedness
	rd = sext(rs / rt);
}

# DIVU
## DIVU rd, rs, rt
:DIVU is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0110011 & lo_pool0_3 = 0b000 {
	rd = sext(rs / rt);
}

# DVP
## DVP rt
:DVP is hi_pool10_6 = 0b001000 & rt ; lo_pool11_5 = 0b00000 & lo_pool10_1 = 0b0 & lo_pool3_7 = 0b1110010 & lo_pool0_3 = 0b000 {
	# NOTE: not sure how to handle coprocessor instructions
}

# EHB
## EHB
:EHB is hi_pool10_6 = 0b001000 & hi_pool5_5 = 0b00000 ; lo_pool12_4 = 0b1100  & lo_pool5_4 = 0b0000 & lo_pool0_5 = 0b00011 {
	# NOTE: not sure how to handle coprocessor instructions
}

# EI
## EI rt
:EI rt is hi_pool10_6 = 0b001000 & rt ; lo_pool14_2 = 0b01  & lo_pool9_5 = 0b01011 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111 {
	# NOTE: not sure how to handle coprocessor instructions
}

# ERET
## ERET
:ERET is hi_pool10_6 = 0b001000 & hi_pool0_1 = 0b0 ; lo_pool14_2 = 0b11 & lo_pool9_5 = 0b11001  & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111 {
	# NOTE: not sure how to handle coprocessor instructions
}

# ERETNC
## ERETNC
:ERETNC is hi_pool10_6 = 0b001000 & hi_pool0_1 = 0b1 ; lo_pool14_2 = 0b11 & lo_pool9_5 = 0b11001  & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111 {
	# NOTE: not sure how to handle coprocessor instructions
}

# EVP
## EVP rt
:EVP rt is hi_pool10_6 = 0b001000 & rt ; lo_pool11_5 = 0b00000  & lo_pool10_1 = 0b1 & lo_pool3_7 = 0b1110010 & lo_pool0_3 = 0b000 {
	# NOTE: not sure how to handle coprocessor instructions
}

# EXT ()
## EXT rt, rs, pos, size
#:EXT rt is hi_pool10_6 = 0b001000 & rt ; lo_pool14_2 = 0b01  & lo_pool9_5 = 0b01011 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111 {
#	# NOTE: not sure how to handle coprocessor instructions
#}

# EXTW()
## EVP rt, rs, pos, size
#:EVP rt is hi_pool10_6 = 0b001000 & rt ; lo_pool14_2 = 0b01  & lo_pool9_5 = 0b01011 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111 {
#	# NOTE: not sure how to handle coprocessor instructions
#}

# GINV()
## GINV rt
:GINV rs is hi_pool10_6 = 0b001000 & rs ; lo_pool14_2 = 0b00  & lo_pool9_5 = 0b01111 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111 {
	# NOTE: not sure how to handle coprocessor instructions
}

# GINVT()
## GINVT rt
#:GINV rt is hi_pool10_6 = 0b001000 & rt ; lo_pool14_2 = 0b01  & lo_pool9_5 = 0b01011 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111 {
#	# NOTE: not sure how to handle coprocessor instructions
#}

# INS()
## INS rt
#:INS  rt is hi_pool10_6 = 0b001000 & rt ; lo_pool14_2 = 0b01  & lo_pool9_5 = 0b01011 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111 {
#	# NOTE: not sure how to handle coprocessor instructions
#}

# JRC
:JRC rt is hi_pool10_6 = 0b110110 & rt & hi_pool4_1 = 0 & hi_pool0_4 = 0b0000 {
	pc = rt;
}

## TODO: JALRC instrs

# LB
## LB rt, offset(rs)
:LB rt, lo_uimm0_12(rs) is hi_pool10_6 = 0b100001 & rt & rs; lo_pool12_4 = 0b0000 & lo_uimm0_12 {
	rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
}

# LB
## LB[16] rt3, offset(rs3)
:LB rt3, hi_uimm0_2(rs3) is hi_pool10_6 = 0b010111 & rt3 & rs3 & hi_uimm0_2 {
	rt3 = *(rs3 + hi_uimm0_2); # TODO: currently updating this to be correct, this is not correct atm
}

# LB
## LB[GP] rt, offset(gp)
:LB rt, lo_pool0_16(gp) is hi_pool10_6 = 0b100001 & rt & hi_pool2_3 = 0b000 & hi_pool0_2; lo_pool0_16 & gp{
	#rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
	#TODO: Need to reference the uim12 example provided by LB
}

# LB
## LB[S9] rt, offset(s9)
:LB rt, lo_pool0_8(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b0000 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b00 & lo_pool0_8 {
	#rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
}

# LBE
## LBE rt, offset(rs)
:LBE rt, lo_pool0_8(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b0000 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10 & lo_pool0_8 {
	#rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
}

# LBU
## LBU rt, offset(rs)
:LBU rt, lo_uimm0_12(rs) is hi_pool10_6 = 0b100001 & rt & rs; lo_pool12_4 = 0b0010 & lo_uimm0_12 {
	rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
}

# LBU
## LBU[16] rt3, offset(rs3)
:LBU rt3, hi_pool0_2(rs3) is hi_pool10_6 = 0b010111 & rt3 & rs3 & hi_pool2_2 = 0b10 & hi_pool0_2  {
	# TODO: make the number and also reference original example maybe
	rt3 = *(rs3 + hi_pool0_2); # TODO: currently updating this to be correct, this is not correct atm
}

# LBUE
## LBUE rt, offset(rs)
:LBUE rt, lo_pool0_8(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b0010 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10 & lo_pool0_8 {
	#rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
}

# LBUX
## LBUX rd, rs(rt)
:LBUX rd, rs(rt) is hi_pool10_6 = 0b001000 & rt & rs; rd  & lo_pool7_4 = 0b0010 & lo_pool6_1 = 0b0 & lo_pool3_3 = 0b000 & lo_pool0_3 = 0b111 {
	# NOTE: not sure how to handle coprocessor instructions
}

# LBX
## LBX rt, offset(rs)
:LBUX rd, rs(rt) is hi_pool10_6 = 0b001000 & rt & rs; rd  & lo_pool7_4 = 0b0000 & lo_pool6_1 = 0b0 & lo_pool3_3 = 0b000 & lo_pool0_3 = 0b111 {
	# NOTE: not sure how to handle coprocessor instructions
}

# LH
## LH rt, offset(rs)
:LH rt, lo_uimm0_12(rs) is hi_pool10_6 = 0b100001 & rt & rs; lo_pool12_4 = 0b0100 & lo_uimm0_12 {
	rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
}

# LH
## LH[16] rt, offset(rs)
:LH rt3, hi_pool1_2(rs3) is hi_pool10_6 = 0b011111 & rt3 & rs3 & hi_pool3_1 = 0b0 & hi_pool1_2 & hi_pool0_1 = 0b0  {
	# TODO: make the number and also reference original example maybe
	rt3 = *(rs3 + hi_pool1_2); # TODO: currently updating this to be correct, this is not correct atm
}

# LH
## LH rt, offset(gp)
:LH rt, lo_pool1_15(gp) is hi_pool10_6 = 0b100001 & rt & hi_pool2_3 = 0b100 & hi_pool0_2; lo_pool1_15 & lo_pool0_1 = 0b0 & gp{
	#rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
	#TODO: Need to reference the uim12 example provided by LB
}

# LH
## LH rt, offset(s9)
:LH rt, lo_pool0_8(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b0100 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b00 & lo_pool0_8 {
	#rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
}

# LHE
## LHE rt, offset(rs)
:LHE rt, lo_pool0_8(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b0100 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10 & lo_pool0_8 {
	#rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
}

# LHU
## LHU[u12] rt, offset(rs)
:LHU rt, lo_uimm0_12(rs) is hi_pool10_6 = 0b100001 & rt & rs; lo_pool12_4 = 0b0110 & lo_uimm0_12 {
	rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
}

# LHU
## LHU[16] rt, offset(rs)
:LHU rt3, hi_pool1_2(rs3) is hi_pool10_6 = 0b011111 & rt3 & rs3 & hi_pool3_1 = 0b1 & hi_pool1_2 & hi_pool0_1 = 0b0  {
	# TODO: make the number and also reference original example maybe
	rt3 = *(rs3 + hi_pool1_2); # TODO: currently updating this to be correct, this is not correct atm
}

# LHU
## LHU[GP] rt, offset(rs)
:LHU rt, lo_pool1_15(gp) is hi_pool10_6 = 0b100001 & rt & hi_pool2_3 = 0b100 & hi_pool0_2; lo_pool1_15 & lo_pool0_1 = 0b1 & gp{
	#rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
	#TODO: Need to reference the uim12 example provided by LB
}

# LHU
## LHU[S9] rt, offset(rs)
:LHU rt, lo_pool0_8(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b0110 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b00 & lo_pool0_8 {
	#rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
}

# LHUE
## LHUE rt, offset(rs)
:LHUE rt, lo_pool0_8(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b0110 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10 & lo_pool0_8 {
	#rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
}
# LHUX
## LHUX rt, offset(rs)
:LHUX rd, rs(rt) is hi_pool10_6 = 0b001000 & rt & rs; rd  & lo_pool7_4 = 0b0110 & lo_pool6_1 = 0b0 & lo_pool3_3 = 0b000 & lo_pool0_3 = 0b111 {
	# NOTE: not sure how to handle coprocessor instructions
}

# LHUXS
## LHUXS rt, offset(rs)
:LHUXS rd, rs(rt) is hi_pool10_6 = 0b001000 & rt & rs; rd  & lo_pool7_4 = 0b0110 & lo_pool6_1 = 0b1 & lo_pool3_3 = 0b000 & lo_pool0_3 = 0b111 {
	# NOTE: not sure how to handle coprocessor instructions
}

# LHX
## LHX rt, offset(rs)
:LHX rd, rs(rt) is hi_pool10_6 = 0b001000 & rt & rs; rd  & lo_pool7_4 = 0b0100 & lo_pool6_1 = 0b0 & lo_pool3_3 = 0b000 & lo_pool0_3 = 0b111 {
	# NOTE: not sure how to handle coprocessor instructions
}

# LHXS
## LHXS rt, offset(rs)
:LHXS rd, rs(rt) is hi_pool10_6 = 0b001000 & rt & rs; rd  & lo_pool7_4 = 0b0100 & lo_pool6_1 = 0b1 & lo_pool3_3 = 0b000 & lo_pool0_3 = 0b111 {
	# NOTE: not sure how to handle coprocessor instructions
}

# LI
## LI[16]
:LI rt3, s is hi_pool10_6 = 0b110100 & rt3 & eu_imm7 = 127 [s = -1;] {
	rt3 = s;
}

:LI rt3, eu_imm7 is hi_pool10_6 = 0b110100 & rt3 & eu_imm7 {
	rt3 = eu_imm7;
} 

## LI[48]
:LI rt, s32 is hi_pool10_6 = 0b011000 & rt & hi_pool0_5 = 0b00000; lo_imm16; hi_imm16 [s32 = (hi_imm16 << 16) | lo_imm16;] {
	rt = s32;
	# TODO: is signedness maintained correctly?
}

# LL
## LL rt, offset(rs)
:LL rt, lo_pool2_6(rs) is hi_pool10_6 = 0b101001  & rt & rs ; lo_pool15_1 & lo_pool11_4 = 0b1010  & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b01 & lo_pool2_6 & lo_pool0_2 = 0b00 {
	# TODO: chage lo_pool to usim
	# TODO: complete loading functionality
}

# LLE
## LLE rt, offset(rs)
:LLE rt, lo_pool2_6(rs) is hi_pool10_6 = 0b101001  & rt & rs ; lo_pool15_1 & lo_pool11_4 = 0b1010  & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10 & lo_pool2_6 & lo_pool0_2 = 0b00 {
	# TODO: chage lo_pool to usim
	# TODO: complete loading functionality
}

# LLWP
## LLWP rt, offset(rs)
:LLWP rt, lo_pool3_5(rs) is hi_pool10_6 = 0b101001  & rt & rs ; lo_pool11_4 = 0b1010  & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b01 & lo_pool3_5 & lo_pool0_2 = 0b01 {
	# TODO: chage lo_pool to usim
	# TODO: complete loading functionality
}

# LLWPE
## LLWPE rt, offset(rs)
:LLWPE rt, lo_pool3_5(rs) is hi_pool10_6 = 0b101001  & rt & rs ; lo_pool11_4 = 0b1010  & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10 & lo_pool3_5 & lo_pool0_2 = 0b01 {
	# TODO: chage lo_pool to usim
	# TODO: complete loading functionality
}

# LSA
## LSA rd, rs, rt, u2
:LHXS rd, rs, rt, lo_pool9_2 is hi_pool10_6 = 0b001000 & rt & rs; rd  & lo_pool9_2 & lo_pool3_3 = 0b001 & lo_pool0_3 = 0b111 {
	# NOTE: finsish the operation
}

# LUI()
## LUI rt, offset(rs)
:LUI  rt is hi_pool10_6 = 0b111000 & rt & hi_pool0_5; lo_pool12_4 & lo_pool2_10 & lo_pool1_1 = 0b0 & lo_pool0_1 {
	# TODO: finish out constructing the number 's'
	# TODO: finish out operation
}

# LW
## LW rt, offset(rs)
:LW rt, lo_uimm0_12(rs) is hi_pool10_6 = 0b100001 & rt & rs; lo_pool12_4 = 0b1000 & lo_uimm0_12 {
	rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
}

# LW16
## LW16 rt3, offset(rs3)
:LW rt3, u_imm4(rs3) is hi_pool10_6 = 0b000101 & rt3 & rs3 & u_imm4 {
	rt3 = *(rs3 + u_imm4); # TODO: currently updating this to be correct, this is not correct atm
}

# LW[SP]
## LW rt, offset(sp)
:LW rt, off(sp) is hi_pool10_6 = 0b001101 & rt & u_imm5 & sp [off = (u_imm5 * 4);] {
	rt = *(sp + off); # TODO: update this to point to certain regions of space (i.e. ram, etc.), this syntax is seemingly wrong
}

# LW[GP16]
## LW rt, offset(sp)
:LW rt3, off(gp) is hi_pool10_6 = 0b0010101 & rt3 & eu_imm7 & gp [off = (eu_imm7 * 4);] {
	rt3 = *(gp + off); # TODO: update this to point to certain regions of space (i.e. ram, etc.), this syntax is seemingly wrong
}

# LW[GP]
## LW rt, offset(sp)
:LW rt, off(gp) is hi_pool10_6 = 0b010000 & rt & u_imm5; lo_pool2_14 & lo_pool0_2 = 0b10 & gp [off = (u_imm5 * 4);] {
	rt = *(gp + off); # TODO: update this to point to certain regions of space (i.e. ram, etc.), this syntax is seemingly wrong
}

# LW[S9]
## LW rt, offset(sp)
:LW rt, lo_pool0_8(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b1000 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b00 & lo_pool0_8 {
	#rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
	#TODO: finish out the logic
}

# LWE
## LWE rt, offset(sp)
:LWE rt, lo_pool0_8(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b1000 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10 & lo_pool0_8 {
	#rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
	#TODO: finish out the logic
}

# LWM
## LWM rt, offset(sp)
:LWM rt, lo_pool0_8(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool12_3 & lo_pool11_1 = 0b0 & lo_pool10_1 = 0b1 & lo_pool8_2 = 0b00 & lo_pool0_8 {
	#rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
	#TODO: finish out the logic
}

# LWPC
## LWPC rt, offset(sp)
#:LWPC rt, lo_pool0_8(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool12_3 & lo_pool11_1 = 0b0 & lo_pool10_1 = 0b1 & lo_pool8_2 = 0b00 & lo_pool0_8 {
#	#rt = *(rs + lo_uimm0_12); # TODO: currently updating this to be correct, this is not correct atm
#	#TODO: make the number
#	#TODO: finish out the logic
#}

# LWX
## LWX rt, offset(sp)
:LWX rd, rs(rt) is hi_pool10_6 = 0b001000 & rt & rs; rd  & lo_pool7_4 = 0b1000 & lo_pool6_1 = 0b0 & lo_pool3_3 = 0b000 & lo_pool0_3 = 0b111 {
	# NOTE: not sure how to handle coprocessor instructions
}

# LWXS
## LWXS rt, offset(sp)
:LWXS rd, rs(rt) is hi_pool10_6 = 0b001000 & rt & rs; rd  & lo_pool7_4 = 0b1000 & lo_pool6_1 = 0b1 & lo_pool3_3 = 0b000 & lo_pool0_3 = 0b111 {
	# NOTE: not sure how to handle coprocessor instructions
}

# MFC0
## MFC0 rt, c0s, sel
:MFC0 rt, c0s, sel is hi_pool10_6 = 0b001000 & rt & c0s; sel & lo_pool3_7 = 0b0000110 & lo_pool0_3 = 0b000 {
	#TODO: read register and sign extend
}

# MFHC0
## MFHC0 rt, c0s, sel
:MFHC0 rt, c0s, sel is hi_pool10_6 = 0b001000 & rt & c0s; sel & lo_pool3_7 = 0b0000111 & lo_pool0_3 = 0b000 {
	#TODO: read register and sign extend
}

# MOD
## MOD rd, rs, rt
:MOD rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0101011 & lo_pool0_3 = 0b000 {
	rd = rs % rt;
}

# MODU
## MOD rd, rs, rt
:MODU rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0111011 & lo_pool0_3 = 0b000 {
	# TODO :zero extend
	rd = rs % rt;
}

# MOVE
## MOVE rt, rs
:MOVE rt, rs is hi_pool10_6 = 0b000100 & rt & rs {
	rt = rs;
}

# MOVE.BALC ()
## MOVE.BALC rt, rs
#:MOVE.BALC rt, rs is hi_pool10_6 = 0b000100 & rt & rs {
#	rt = rs;
#}

# MOVEP ()
## MOVE rt, rs
#:MOVE rt, rs is hi_pool10_6 = 0b000100 & rt & rs {
#	rt = rs;
#}

# MOVN
## MOVN rd, rs, rt
:MOVN rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool10_1 = 1 & lo_pool3_7 = 0b1000010 & lo_pool0_3 = 0b000 {
	#TODO: work out zero logic with rt
	rd = rs;
}

# MOVZ
## MOVZ rd, rs, rt
:MOVZ rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool10_1 = 0 & lo_pool3_7 = 0b1000010 & lo_pool0_3 = 0b000 {
	#TODO: work out zero logic with rt
	rd = rs;
}

# MTC0
## MTC0 rt, c0s, sel
:MTC0 rt, c0s, sel is hi_pool10_6 = 0b001000 & rt & c0s; sel & lo_pool3_7 = 0b0001110 & lo_pool0_3 = 0b000 {
	#TODO: read register and sign extend
}

# MTHC0
## MTHC0 rt, c0s, sel
:MTHC0 rt, c0s, sel is hi_pool10_6 = 0b001000 & rt & c0s; sel & lo_pool3_7 = 0b0001111 & lo_pool0_3 = 0b000 {
	#TODO: read register and sign extend
}

# MUH
## MUH rd, rs, rt
:MUH rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0001011 & lo_pool0_3 = 0b000 {
	rd = rs * rt;
}

# MUHU
## MUHU  rd, rs, rt
:MUHU rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0011011 & lo_pool0_3 = 0b000 {
	rd = rs * rt;
}

# MUL
## MUL rd, rs, rt
:MUL rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0000011 & lo_pool0_3 = 0b000 {
	rd = rs * rt;
}

# MULU
## MUL rd, rs, rt
:MULU rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0010011 & lo_pool0_3 = 0b000 {
	rd = rs * rt;
}

# NOP
## NOP
:NOP is hi_pool10_6 = 0b100000 & hi_pool5_5 = 0b00000; lo_pool12_4 = 0b1100 & lo_pool5_4 = 0b0000 & lo_pool0_5 = 0b00000 { }

# NOP
## NOP
:NOP is hi_pool10_6 = 0b100100 & hi_pool5_5 = 0b00000 & hi_pool3_1 = 0b0 { }

# NOR
## NOR rd, rs, rt
:NOR rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b1011010 & lo_pool0_3 = 0b000 {
	rt = ~(rs | rt);
}

# NOT
## NOT[16] rt, rs
:NOT rt3, rs3 is hi_pool10_6 = 0b001000 & rt3 & rs3 {
	rt3 = ~(rs3);
}

# OR
## OR rd, rs, rt
:OR rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b1010010 & lo_pool0_3 = 0b000 {
	rd = rs | rt;
}

## OR[16]
:OR rt3, rs3 is hi_pool10_6 = 0b010100 & rt3 & rs3 & hi_pool2_2 = 0b11 & hi_pool1_1 = 0 & hi_pool0_1 = 0 {
	rt3 = rs3 ^ rt3;
}

# ORI
## OR rd, rs, rt
:ORI rt, rs, lo_uimm0_12 is hi_pool10_6 = 0b100000 & rt & rs; lo_pool12_4 = 0b0000 & lo_uimm0_12 {
	rt = rs | lo_uimm0_12;
}

# PAUSE
## PAUSE rd, rs, rt
:PAUSE is hi_pool10_6 = 0b100000 & hi_pool5_5 = 0b00000; lo_pool12_4 = 0b1100 & lo_pool5_4 = 0b0000 & lo_pool0_5 = 0b00101 unimpl

# PREF
## PREF hint, offset(rs)
## TODO: make a custom hint register
:PREF rt, lo_pool0_8(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b0011 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b00 & lo_pool0_8 {
	rt = *(rs + lo_pool0_8); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
}

# PREF
## PREF[U12[ hint, offset(rs)
## TODO: make a custom hint register
:PREF rt, lo_uimm0_12(rs) is hi_pool10_6 = 0b100001 & rt & rs; lo_pool12_4 = 0b0011 & lo_uimm0_12 {
	*(rs + lo_uimm0_12) = rt; # TODO: currently updating this to be correct, this is not correct atm
}

# PREFE
## PREFE hint, offset(rs)
## TODO: make a custom hint register
:PREFE rt, lo_pool0_8(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b0011 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10 & lo_pool0_8 {
	rt = *(rs + lo_pool0_8); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
}

# RDHWR ()
## RDHWR rd, rs, rt
#:RDHWR rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0000011 & lo_pool0_3 = 0b000 {
#	rd = rs * rt;
#}

# RDPGPR
## RDPGPR rd, rs, rt
:RDPGPR rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool14_2 = 0b11 & lo_pool9_5 = 0b10000 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111 unimpl

# RESTORE.JRC
## RESTORE>JRC[16] u, [ src1 [, src2 [ ..,]]
## TODO: figure out how to display registers (seems complicated)
:RESTORE.JRC is hi_pool10_6 = 0b000111 & rt1 & hi_pool8_1 = 1 &  u_imm4_4 & u_imm4 {

}

# RESTORE
## RESTORE[32] u, [ src1 [, src2 [ ..,]]
## TODO: figure out how to display registers (seems complicated)
:RESTORE is hi_pool10_6 = 0b100000  & rt & hi_pool4_1 = 0 & hi_pool0_4; lo_pool12_4 = 0b0011 & lo_pool3_9 & lo_pool2_1 & lo_pool0_2 = 0b10 {

}

# RESTORE
## RESTORE.JRC[32] u, [ src1 [, src2 [ ..,]]
## TODO: figure out how to display registers (seems complicated)
:RESTORE.JRC is hi_pool10_6 = 0b100000  & rt & hi_pool4_1 & hi_pool0_4; lo_pool12_4 = 0b0011 & lo_pool3_9 & lo_pool2_1 & lo_pool0_2 = 0b11 {

}

# ROTR
## ROTR rd, rs, shift
:ROTR rt, rs, lo_pool0_5 is hi_pool10_6 = 0b100000 & rt & rs; lo_pool12_4 = 0b1100 & lo_pool5_4 = 0b0110 & lo_pool0_5 {
	# TODO: sign extend
	rt = rs >> lo_pool0_5;
}

# ROTRV
## ROTRV rd, rs, shift
:ROTRV rd, rs, rt is hi_pool10_6 = 0b100000 & rt & rs; rd & lo_pool3_7 = 0b0011010 & lo_pool0_3 = 0b000 {
	# TODO: complete operation
	# TODO: sign extend
	rd = rs >> rt;
}

# ROTX ()
## ROTX rd, rs, shift
#:ROTX rt, rs, lo_pool0_5 is hi_pool10_6 = 0b100000 & rt & rs; lo_pool12_4 = 0b1100 & lo_pool5_4 = 0b0110 & lo_pool0_5 {
#	# TODO: sign extend
#	rt = rs >> lo_pool0_5;
#}

# SB
## SB rt, offset(rs)
:SB rt, lo_uimm0_12(rs) is hi_pool10_6 = 0b100001 & rt & rs; lo_pool12_4 = 0b0001 & lo_uimm0_12 {
	#TODO: save only a byte? (specify 8 bits?)
	*(rs + lo_uimm0_12) = rt; # TODO: currently updating this to be correct, this is not correct atm
}

# SB
## SB[16] rt, offset(rs)
## TODO: replace with rtz3
## TODO: make uim
:SB rt3, hi_pool0_2(rs3) is hi_pool10_6 = 0b100111 & rt3 & rs3 & hi_pool2_2 = 0b01 & hi_pool0_2 {
	*(rs3 + hi_pool0_2) = rt3; # TODO: currently updating this to be correct, this is not correct atm
}

# SB
## SB[GP] rt, offset(rs)
##TODO:  SB[GP]/[s9[
:SB rt, lo_pool0_16(gp) is hi_pool10_6 = 0b010001 & rt & hi_pool2_3 = 0b001 & hi_pool0_2; lo_pool0_16 & gp {
	#TODO: save only a byte? (specify 8 bits?)
	#*(rs + lo_uimm0_12) = rt; # TODO: currently updating this to be correct, this is not correct atm
}

# SB
## SB[S9] rt, offset(rs)
:SB rt, lo_pool0_8(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b0001 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b00 & lo_pool0_8 {
	rt = *(rs + lo_pool0_8); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
}

# SBE
## SBE rd, rs, shift
:SBE rt, lo_pool0_8(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b0001 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10 & lo_pool0_8 {
	rt = *(rs + lo_pool0_8); # TODO: currently updating this to be correct, this is not correct atm
	#TODO: make the number
}
# SBX
## SBX rd, rs, shift
:SBX rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool7_4 = 0b0001 & lo_pool6_1 = 0b0 & lo_pool3_3 = 0b000 & lo_pool0_3 = 0b111 {

}

# SC ()
## SC rd, rs, shift
:SC rt, lo_pool2_6(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b1011 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b01 & lo_pool2_6 & lo_pool0_2 = 0b00 {
	#*(rs3 + hi_pool0_2) = rt3; # TODO: currently updating this to be correct, this is not correct atm
}

# SCE ()
## SCE rd, rs, shift
:SCE rt, lo_pool2_6(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b1011 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10 & lo_pool2_6 & lo_pool0_2 = 0b00 {
	#*(rs3 + hi_pool0_2) = rt3; # TODO: currently updating this to be correct, this is not correct atm
}

# SCWP ()
## SCWP rd, rs, shift
:SCWP rt, lo_pool3_5(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b1011 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b01 & lo_pool3_5 & lo_pool0_2 = 0b01 {
	#*(rs3 + hi_pool0_2) = rt3; # TODO: currently updating this to be correct, this is not correct atm
}

# SCWPE ()
## SCWPE rd, rs, shift
:SCWPE rt, lo_pool3_5(rs) is hi_pool10_6 = 0b101001 & rt & rs; lo_pool15_1 & lo_pool11_4 = 0b1011 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10 & lo_pool3_5 & lo_pool0_2 = 0b01 {
	#*(rs3 + hi_pool0_2) = rt3; # TODO: currently updating this to be correct, this is not correct atm
}

# SDBBP
## SDBBP
:SDBBP is hi_pool10_6 = 0b000000 & hi_pool5_5 = 0b00000 & hi_pool3_2 = 0b11 & hi_pool0_3; lo_pool0_16 {
	# TODO: construct the code
	#rt = rs >> lo_pool0_5;
}

# SDBBP
## SDBBP[16]
:SDBBP is hi_pool10_6 = 0b001000 & hi_pool5_5 = 0b00000 & hi_pool3_2 = 0b11 & hi_pool0_2 {
	# TODO: construct the code
}


# SEB rt, rs
:SEB rt, rs is
	hi_pool10_6 = 0b001000 & rt & rs;
	lo_pool3_7 = 0b0000001 & lo_pool0_3 = 0b000
	{
		rt = sext(rs:1);
	}


# SEH rt, rs
:SEH rt, rs is
	hi_pool10_6 = 0b001000 & rt & rs;
	lo_pool3_7 = 0b0001001 & lo_pool0_3 = 0b000
	{
		rt = sext(rs:2);
	}


# SEQI rt, rs, u
:SEQI rt, rs, lo_uimm0_12 is
	hi_pool10_6 = 0b100000 & rt & rs;
	lo_pool12_4 = 0b0110 & lo_uimm0_12
	{
		# TODO verify == output is 0 or 1
		rt = zext(rs == lo_uimm0_12);
	}


# SH rt, offset(rs)
## SH[U12]
:SH rt, lo_rs_uoffset12 is
	(hi_pool10_6 = 0b100001 & rt;
	lo_pool12_4 = 0b0101)
	& lo_rs_uoffset12
	{
		*:2 lo_rs_uoffset12 = rt:2;
	}

## SH[16]
:SH rtz3, hi_rs3_uoffset3 is
	hi_pool10_6 = 0b011111 & rtz3 & hi_rs3_uoffset3 & hi_pool3_1 = 0b0 & hi_pool0_1 = 0b1
	{
		*:2 hi_rs3_uoffset3 = rtz3:2;
	}

## SH[GP]
:SH rt, hilo_gp_uoffset18 is
	(hi_pool10_6 = 0b010001 & rt & hi_pool2_3 = 0b101;
	lo_pool0_1 = 0b0)
	& hilo_gp_uoffset18
	{
		*:2 hilo_gp_uoffset18 = rt:2;
	}

## SH[S9]
:SH rt, lo_rs_soffset9 is
	(hi_pool10_6 = 0b101001 & rt;
	lo_pool11_4 = 0b0101 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b00)
	& lo_rs_soffset9
	{
		*:2 lo_rs_soffset9 = rt:2;
	}


# SLL
## SLL rd, rs, shift
:SLL rt, rs, lo_pool0_5 is hi_pool10_6 = 0b100000 & rt & rs; lo_pool12_4 = 0b1100 & lo_pool5_4 = 0b0000 & lo_pool0_5 {
	rt = rs << lo_pool0_5;
}

# SLL
## SLL[16] rt3, rs3, shift
:SLL rt3, rs3, hi_pool0_3 is hi_pool10_6 = 0b001100 & rt3 & rs3 & hi_pool3_1 = 0 & hi_pool0_3 {
	rt3 = rs3 << hi_pool0_3;
}




# SLLV
## SLLV rd, rs, shift
:SLLV rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0000010 & lo_pool0_3 = 0b000 {
	rd = rs << (rt & 0x1f);
}

# SLT
## SLT rd, rs, rt
:SLT rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b1101010 & lo_pool0_3 = 0b000 {
	#TODO: finish this out
}




# SLTI
## SLTI rd, rs, rt
:SLTI rt, rs, lo_pool0_12 is hi_pool10_6 = 0b100000  & rt & rs; lo_pool12_4 = 0b0100 & lo_pool0_12 {
	#TODO: finish this out
}

# SLTIU
## SLTIU rd, rs, rt
:SLTIU rt, rs, lo_pool0_12 is hi_pool10_6 = 0b100000  & rt & rs; lo_pool12_4 = 0b0101 & lo_pool0_12 {
	#TODO: finish this out
}

# SLTU
## SLTU rd, rs, rt
:SLTU rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b1110010 & lo_pool0_3 = 0b000 {
	sum = rs + rt;
	#TODO: finish this out
}

# SOV
## SOV rd, rs, rt
:SOV rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b1111010 & lo_pool0_3 = 0b000 {
	sum = rs + rt;
	#TODO: finish this out
}

# SRA
## SRA rd, rs, shift
:SRA rt, rs, lo_pool0_5 is hi_pool10_6 = 0b100000 & rt & rs; lo_pool12_4 = 0b1100 & lo_pool5_4 = 0b0100 & lo_pool0_5 {
	rt = rs >> lo_pool0_5;
}

# SRAV
## SRAV rd, rs, rt
:SRAV rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0010010 & lo_pool0_3 = 0b000 {
	rd = rs >> (rt & 0x1f);
}

# SRL
## SRL rd, rs, shift
:SRL rt, rs, lo_pool0_5 is hi_pool10_6 = 0b100000 & rt & rs; lo_pool12_4 = 0b1100 & lo_pool5_4 = 0b0010 & lo_pool0_5 {
    # TODO: incorporate signed extend
	rt = rs >> lo_pool0_5;
}

# SRL
## SRL[16] rt3, rs3, shift
:SRL rt3, rs3, hi_pool0_3 is hi_pool10_6 = 0b001100 & rt3 & rs3 & hi_pool3_1 = 1 & hi_pool0_3 {
	# TODO: incorporate signe extend
	rt3 = rs3 >> hi_pool0_3;
}

# SRLV
## SRLV rd, rs, rt
:SRLV rd, rs, rt is hi_pool10_6 = 0b100000 & rt & rs; rd & lo_pool3_7 = 0b0001010 & lo_pool0_3 = 0b000 {
    # TODO: incorporate signed extend
	rd = rs >> (rt & 0x1f);
}

# SUB rd, rs, rt
:SUB rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0110010 & lo_pool0_3 = 0b000 {
	rd = rs - rt;
	# TODO: trap on overflow
	# TODO: sign extend?
}

# SUBU rd, rs, rt
:SUBU rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b0111010 & lo_pool0_3 = 0b000 {
	rd = rs - rt;
	# TODO: trap on overflow
	# TODO: sign extend?
}

# SUBU rt, rs, imm
## SUBU[16]
# TODO: rt != 0 constraint doesn't work here (covered by SIGRIE?)
:SUBU rd3, rs3, rt3 is hi_pool10_6 = 0b101100  & rt3 & rs3 & rd3 & hi_pool0_1 = 0b1 {
	rd3 = rs3 + rt3;
}

# SW rt, offset(rs)
## SW[U12]
:SW rt, lo_rs_uoffset12 is
	(hi_pool10_6 = 0b100001 & rt;
	lo_pool12_4 = 0b1001)
	& lo_rs_uoffset12
	{
		*:4 lo_rs_uoffset12 = rt:4;
	}

## SW[16]
:SW rtz3, hi_rs3_uoffset6 is
	hi_pool10_6 = 0b100101 & rtz3 & hi_rs3_uoffset6
	{
		*:4 hi_rs3_uoffset6 = rtz3:4;
	}

# SW[SP]
## SW rt, offset(sp)
:SW rt, off(sp) is hi_pool10_6 = 0b101101 & rt & u_imm5 & sp [off = (u_imm5 * 4);] {
	*(sp + off) = rt; # TODO: update this to point to certain regions of space (i.e. ram, etc.), this syntax is seemingly wrong
}

# SAVE
## SAVE[16] u, [ src1 [, src2 [ ..,]]
## TODO: figure out how to display registers (seems complicated)
:SAVE is hi_pool10_6 = 0b000111 & rt1 & hi_pool8_1 = 0 &  u_imm4_4 & u_imm4 {

}

# SAVE
## SAVE[32] u, [ src1 [, src2 [ ..,]]
## TODO: figure out how to display registers (seems complicated)
:SAVE is hi_pool10_6 = 0b100000  & rt & hi_pool4_1 = 0 & hi_pool0_4; lo_pool12_4 = 0b0011 & lo_pool3_9 = 0 & lo_pool2_1 & lo_pool0_2 = 0b00 {

}

# SIGRIE code
# TODO: Signal Reserved Instruction Exception
:SIGRIE code is hi_pool10_6 = 0b000000 & rt = 0 & hi_pool3_2 = 0b00 & hi_uimm0_3; uimm16
	[code = (hi_uimm0_3 << 16) | uimm16;] unimpl


# SYNC stype
## stype=0 implied
:SYNC is
	hi_pool10_6 = 0b100000 & hi_pool5_5 = 0b00000 & hi_uimm0_5 = 0;
	lo_pool12_4 = 0b1100 & lo_pool5_4 = 0b0000 & lo_pool0_5 = 0b00110
	{}

:SYNC hi_uimm0_5 is
	hi_pool10_6 = 0b100000 & hi_pool5_5 = 0b00000 & hi_uimm0_5;
	lo_pool12_4 = 0b1100 & lo_pool5_4 = 0b0000 & lo_pool0_5 = 0b00110
	{}


# SYNCI(E) offset(rs)
## SYNCI[S9]
:SYNCI lo_soffset9(rs) is
	hi_pool10_6 = 0b101001 & hi_pool5_5 = 0b11111 & rs;
	lo_pool11_4 = 0b0011 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b00 & lo_soffset9
	{}

## SYNCI[U12]
:SYNCI lo_uimm0_12(rs) is
	hi_pool10_6 = 0b100001 & hi_pool5_5 = 0b11111 & rs;
	lo_pool12_4 = 0b0011 & lo_uimm0_12
	{}

## SYNCIE, present when Config5.EVA=1, requires CP0 privilege.
:SYNCIE lo_soffset9(rs) is
	hi_pool10_6 = 0b101001 & hi_pool5_5 = 0b11111 & rs;
	lo_pool11_4 = 0b0011 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b10 & lo_soffset9
	{}


# SYSCALL code
## SYSCALL[32]
:SYSCALL code is
	hi_pool10_6 = 0b000000 & rt = 0 & hi_pool3_2 = 0b01 & hi_pool2_1 = 0b0 & hi_uimm0_2;
	uimm16
	[
		code = (hi_uimm0_2 << 16) | uimm16;
	]
	unimpl

## SYSCALL[16]
:SYSCALL hi_uimm0_2 is
	hi_pool10_6 = 0b000100 & rt = 0 & hi_pool3_2 = 0b01 & hi_pool2_1 = 0b0 & hi_uimm0_2
	unimpl


# TEQ rs, rt, code
:TEQ rs, rt, lo_uimm11_5 is
	hi_pool10_6 = 0b001000 & rt & rs;
	lo_uimm11_5 & lo_pool10_1 = 0b0 & lo_pool3_7 = 0b0000000 & lo_pool0_3 = 0b000
	unimpl


# TLBINV
:TLBINV is
	hi_pool10_6 = 0b001000;
	lo_pool14_2 = 0b00 & lo_pool9_5 = 0b00011 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	unimpl


# TLBINVF
:TLBINVF is
	hi_pool10_6 = 0b001000;
	lo_pool14_2 = 0b00 & lo_pool9_5 = 0b01011 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	unimpl


# TLBP
:TLBP is
	hi_pool10_6 = 0b001000;
	lo_pool14_2 = 0b00 & lo_pool9_5 = 0b00001 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	unimpl


# TLBR
:TLBR is
	hi_pool10_6 = 0b001000;
	lo_pool14_2 = 0b00 & lo_pool9_5 = 0b01001 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	unimpl


# TLBWI
:TLBWI is
	hi_pool10_6 = 0b001000;
	lo_pool14_2 = 0b00 & lo_pool9_5 = 0b10001 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	unimpl


# TLBWR
:TLBWR is
	hi_pool10_6 = 0b001000;
	lo_pool14_2 = 0b00 & lo_pool9_5 = 0b11001 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	unimpl


# TNE rs, rt, code
:TNE rs, rt, lo_uimm11_5 is
	hi_pool10_6 = 0b001000 & rt & rs;
	lo_uimm11_5 & lo_pool10_1 = 0b1 & lo_pool3_7 = 0b0000000 & lo_pool0_3 = 0b000
	unimpl


# UALH rt, offset(rs)
:UALH rt, lo_soffset9(rs) is
	hi_pool10_6 = 0b101001 & rt & rs;
	lo_pool11_4 = 0b0100 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b01 & lo_soffset9
	unimpl


# UALW rt, offset(rs)
## alias for UALWM count=1
:UALW rt, lo_soffset9(rs) is
	hi_pool10_6 = 0b101001 & rt & rs;
	count3 = 1 & lo_pool11_1 = 0b0 & lo_pool10_1 = 0b1 & lo_pool8_2 = 0b01 & lo_soffset9
	unimpl


# UALWM rt, offset(rs), count
:UALWM rt, lo_soffset9(rs), count3 is
	hi_pool10_6 = 0b101001 & rt & rs;
	count3 & lo_pool11_1 = 0b0 & lo_pool10_1 = 0b1 & lo_pool8_2 = 0b01 & lo_soffset9
	unimpl


# UASH rt, offset(rs)
:UASH rt, lo_soffset9(rs) is
	hi_pool10_6 = 0b101001 & rt & rs;
	lo_pool11_4 = 0b0101 & lo_pool10_1 = 0b0 & lo_pool8_2 = 0b01 & lo_soffset9
	unimpl


# UASW rt, offset(rs)
## alias for UASWM count=1
:UASW rt, lo_soffset9(rs) is
	hi_pool10_6 = 0b101001 & rt & rs;
	count3 = 1 & lo_pool11_1 = 0b1 & lo_pool10_1 = 0b1 & lo_pool8_2 = 0b01 & lo_soffset9
	unimpl


# UASWM rt, offset(rs), count
:UASWM rt, lo_soffset9(rs), count3 is
	hi_pool10_6 = 0b101001 & rt & rs;
	count3 & lo_pool11_1 = 0b1 & lo_pool10_1 = 0b1 & lo_pool8_2 = 0b01 & lo_soffset9
	unimpl


# WAIT code
:WAIT is
	hi_pool10_6 = 0b001000 & hi_uimm0_10 = 0;
	lo_pool14_2 = 0b11 & lo_pool9_5 = 0b00001 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	unimpl

:WAIT hi_uimm0_10 is
	hi_pool10_6 = 0b001000 & hi_uimm0_10;
	lo_pool14_2 = 0b11 & lo_pool9_5 = 0b00001 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	unimpl


# WRPGPR rt, rs
# "Write Previous GPR. Write the value of register $rs from the current shadow register set (SRSCtl.CSS) to register $rt in the previous shadow register set (SRSCtl.PSS). If shadow register sets are not implemented, just copy the value from register $rs to register $rt."
# TODO "Requires CP0 privilege."
:WRPGPR rt, rs is
	hi_pool10_6 = 0b001000 & rt & rs;
	lo_pool14_2 = 0b11 & lo_pool9_5 = 0b11000 & lo_pool6_3 = 0b101 & lo_pool3_3 = 0b111 & lo_pool0_3 = 0b111
	{
		# TODO shadow register stuff
		rt = rs;
	}


# XOR rd, rs, rt
## XOR[32]
:XOR rd, rs, rt is hi_pool10_6 = 0b001000 & rt & rs; rd & lo_pool3_7 = 0b1100010 & lo_pool0_3 = 0b000 {
	rd = rs ^ rt;
}

## XOR[16]
:XOR rd3_from_rt3, rs3, rt3 is hi_pool10_6 = 0b010100 & rt3 & rd3_from_rt3 & rs3 & hi_pool2_2 = 0b01 & hi_pool1_1 = 0 & hi_pool0_1 = 0 {
	rd3_from_rt3 = rs3 ^ rt3;
}


# XORI rt, rs, u
:XORI rt, rs, lo_uimm0_12 is
	hi_pool10_6 = 0b100000 & rt & rs;
	lo_pool12_4 = 0b0001 & lo_uimm0_12
	{
		rt = rs ^ lo_uimm0_12;
	}
